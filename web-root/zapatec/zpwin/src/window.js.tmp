// $Id: button.js 6652 2007-03-19 10:19:30Z andrew $
/*
 * <pre>
 * Copyright (c) 2004-2006 by Zapatec, Inc.
 * http://www.zapatec.com
 * 1700 MLK Way, Berkeley, California,
 * 94709, U.S.A.
 * All rights reserved.
 * </pre>
 */

/**
* Zapatec.Button constructor. creates new object with given parameters.
*
* @param config [object] - button config.
*
* Constructor recognizes the following properties of the config object
* \code
*	property name			| description
*-------------------------------------------------------------------------------------------------
*	image			| [String] Default image for button. Also this image will
*					|	be putted on mouseout. Default value – null.
*	width			| [int] Button width. Default value - null.
*	height			| [int] Button height. Default value - null.
*	className		| [string] Default class to apply to newly created
*					|	button. Default value – null.
*	style			| [string] Default style to apply to newly created button.
*					|	Default value – null.
*	text			| [string] Text title to display on button. If
*					|	“image” option was given – this text will be used as
*					|	alternative title.
*	preloadImages	| [boolean] If true – preload all images (image, overImage,
*					|	outImage, downImage) for button. Default value – true.
*	overStyle		| [string] Style to apply to button during mouseover event.
*					|	Default value – null.
*	overClass		| [string] Class to add to button during mouseover event.
*					|	Default value – null.
*	overImage		| [string] Show this image during mouseover event. This
*					|	will be done only if “image” option was specified.
*					|	Default value – null.
*	overAction		| [function] Call this function during mouseover event.
*					|	Default value – null.
*	outAction		| [function] Call this function during mouseout event.
*					|	Default value – null.
*	downStyle		| [string] Style to apply to button during mousedown event.
*					|	Default value – null.
*	downClass		| [string] Class to add to button during mousedown event.
*					|	Default value – null.
*	downImage		| [string] Show this image during mousedown event. This
*					|	will be done only if “image” option was specified.
*					|	Default value – null.
*	downAction		| [function] Call this function during mousedown event.
*					|	Default value – null.
*	clickAction		| [function] Call this function during onclick event.
*	theme			| [string] Theme name.
*	themePath		| [string] Path to directory where theme files are located.
*   idPrefix        | [string] Prefix for HTML ID's that will be assigned to controll elements.
* \endcode
*/
Zapatec.Button = function(objArgs){
	if(arguments.length == 0){
		objArgs = {};
	}

	// Call constructor of superclass
	Zapatec.Button.SUPERconstructor.call(this, objArgs);
};

/**
 * Unique static id of the widget class. Gives ability for Zapatec#inherit to
 * determine and store path to this file correctly when it is included using
 * Zapatec#include. When this file is included using Zapatec#include or path
 * to this file is gotten using Zapatec#getPath, this value must be specified
 * as script id.
 * @private
 */
Zapatec.Button.id = "Zapatec.Button";

// Inherit SuperClass
Zapatec.inherit(Zapatec.Button, Zapatec.Widget);

/**
* Init function. Actually this function does the creation of element
* itself, not the constructor.
*/
Zapatec.Button.prototype.init = function(objArgs){
	this.config.image = null;
	this.config.width = null;
	this.config.height = null;
	this.config.className = null;
	this.config.style = null;
	this.config.text = "";
	this.config.preloadImages = true;
	this.config.overStyle = null;
	this.config.overClass = null;
	this.config.overImage = null;
	this.config.overAction = null;
	this.config.outAction = null;
	this.config.downStyle = null;
	this.config.downClass = null;
	this.config.downImage = null;
	this.config.downAction = null;
	this.config.clickAction = null;
	this.config.idPrefix = null;
	this.config.themePath = Zapatec.zapatecPath + "../zpextra/themes/button/";

	// processing Widget functionality
	Zapatec.Button.SUPERclass.init.call(this, objArgs);
	if (!this.config.idPrefix) {
		this.config.idPrefix = "zpButton" + this.id;
	}

	// store reference to root DOM object
	this.container = null;

	// using this container we could define current button state
	this.statusContainer = null;

	// where content actually located
	this.internalContainer = null;

	// reference to button's image
	this.img = null;

	// indicates current button state
	this.enabled = true;

  this.isPressed = false;

  this.createButton();
};

/**
* \internal creates button object
*/
Zapatec.Button.prototype.createButton = function(){
    Zapatec.Utils.createProperty(this, 'container', Zapatec.Utils.createElement("span"));
	this.container.id = this.config.idPrefix + "Container";
    Zapatec.Utils.createProperty(this, 'statusContainer', Zapatec.Utils.createElement("span"));
	this.statusContainer.className = "mouseOut";
	this.statusContainer.id = this.config.idPrefix + "Status";
	this.container.appendChild(this.statusContainer);
    Zapatec.Utils.createProperty(this, 'internalContainer', Zapatec.Utils.createElement("span"));
	this.internalContainer.className = "internalContainer";
	this.internalContainer.id = this.config.idPrefix + "Internal";
	this.statusContainer.appendChild(this.internalContainer);

	Zapatec.Utils.addClass(this.container, this.getClassName({
		prefix: "zpButton" + (this.config.image != null ? "Image" : ""),
		suffix: "Container"
	}));

	// process config options

	if(this.config.width != null){
		this.internalContainer.style.width = this.config.width + "px";
	}

	if(this.config.height != null){
		this.internalContainer.style.width = this.config.height + "px";
	}

	if(this.config.className != null){
		Zapatec.Utils.addClass(this.internalContainer, this.config.className);
	}

	if(this.config.style != null){
		this.applyStyle(this.config.style);
	}

	var self = this;

	// attach handlers for mouse events
    Zapatec.Utils.createProperty(this.container, 'onmouseover', function(ev){return self.onmouseover(ev);});
    Zapatec.Utils.createProperty(this.container, 'onmouseout', function(ev){return self.onmouseout(ev);});
    Zapatec.Utils.createProperty(this.container, 'onmousedown', function(ev){return self.onmousedown(ev);});
    Zapatec.Utils.createProperty(this.container, 'onmouseup', function(ev){return self.onmouseover(ev);});
    Zapatec.Utils.createProperty(this.container, 'onclick', function(ev){return self.onclick(ev);});

	if(this.config.image != null){
		// create image if needed
        Zapatec.Utils.createProperty(this, 'img', document.createElement("img"));
		this.img.src = this.config.image;
		this.img.alt = this.config.text;
		this.img.title = this.config.text;
		this.internalContainer.appendChild(this.img);
	} else {
		this.internalContainer.innerHTML = this.config.text;
		this.internalContainer.style.whiteSpace = "nowrap";
	}

	if(this.config.preloadImages == true){
		this.preloadImages();
	}
};

/**
* \internal Handler for mouseover event
*/
Zapatec.Button.prototype.onmouseover = function(ev){
	if(!this.isEnabled()){
		return false;
	}

	if(typeof(ev) == 'undefined'){
		ev = window.event;
	}

	this.toggleClass("mouseOver");

	if(this.config.image != null && this.config.overImage != null){
		this.img.src = this.config.overImage;
	}

	if(this.config.overClass != null){
		Zapatec.Utils.addClass(this.internalContainer, this.config.overClass);
	}

	if(this.config.overStyle != null){
		this.applyStyle(this.config.overStyle);
	}

	if(this.config.overAction != null){
		return this.config.overAction(ev, this);
	}

	return true;
};

/**
* \internal Handler for mouseout event
*/
Zapatec.Button.prototype.onmouseout = function(ev){
	if(!this.isEnabled()){
		return false;
	}

	if(typeof(ev) == 'undefined'){
		ev = window.event;
	}

  if (!this.isPressed) {
    this.toggleClass("mouseOut");

    if(this.config.image != null){
      this.img.src = this.config.image;
    }

    if(this.config.outClass != null){
      Zapatec.Utils.addClass(this.internalContainer, this.config.outClass);
    }
  }
  else {
    this.toggleClass("mouseDown");

    if(this.config.image != null && this.config.downImage != null){
      this.img.src = this.config.downImage;
    }

    if(this.config.downClass != null){
      Zapatec.Utils.addClass(this.internalContainer, this.config.downClass);
    }
  }

  if(this.config.style != null){
		this.applyStyle(this.config.style);
	}

	if(this.config.outAction != null){
		return this.config.outAction(ev, this);
	}

	return true;
};

/**
* \internal Handler for mousedown event
*/
Zapatec.Button.prototype.onmousedown = function(ev){
	if(!this.isEnabled()){
		return false;
	}

	if(typeof(ev) == 'undefined'){
		ev = window.event;
	}

	this.toggleClass("mouseDown");

	if(this.config.image != null && this.config.downImage != null){
		this.img.src = this.config.downImage;
	}

	if(this.config.downClass != null){
		Zapatec.Utils.addClass(this.internalContainer, this.config.downClass);
	}

	if(this.config.downStyle != null){
		this.applyStyle(this.config.downStyle);
	}

	if(this.config.downAction != null){
		return this.config.downAction(ev, this);
	}

	return true;
};

/**
* \internal Handler for click event
*/
Zapatec.Button.prototype.onclick = function(ev){
	if(!this.isEnabled()){
		return false;
	}

	if(typeof(ev) == 'undefined'){
		ev = window.event;
	}

	if(this.config.clickAction != null){
		return this.config.clickAction(ev, this);
	}

	return true;
};

/**
* \internal Preload button images
*/
Zapatec.Button.prototype.preloadImages = function(){
	if(this.config.image != null){
		var images = [this.config.image];

		if(this.config.overImage != null){
			images.push(this.config.overImage);
		}

		if(this.config.downImage != null){
			images.push(this.config.downImage);
		}

		Zapatec.Transport.preloadImages({urls: images});
	}
};

/**
 * Sets the button in a pressed state
 *
 * @param isPressed [boolean] if button is to be pressed or not
 */
Zapatec.Button.prototype.setPressed = function(isPressed){
	this.isPressed = isPressed;

	if (isPressed) {
		this.toggleClass('mouseDown');
	} else {
		this.toggleClass('mouseOut');
	}
};

/**
* \internal Removes all classes from buttons and adds given class.
*/
Zapatec.Button.prototype.toggleClass = function(className){
	Zapatec.Utils.removeClass(this.statusContainer, "mouseOver");
	Zapatec.Utils.removeClass(this.statusContainer, "mouseOut");
	Zapatec.Utils.removeClass(this.statusContainer, "mouseDown");
	Zapatec.Utils.removeClass(this.statusContainer, "disabled");
	Zapatec.Utils.removeClass(this.internalContainer, this.config.overClass);
	Zapatec.Utils.removeClass(this.internalContainer, this.config.downClass);

	if(className != null){
		Zapatec.Utils.addClass(this.statusContainer, className);
	}
};

/**
* Get reference to button main DOM object
*/
Zapatec.Button.prototype.getContainer = function(){
	return this.container;
};

/**
* \internal apply given style to button
*	\param style - [string] string value
*/
Zapatec.Button.prototype.applyStyle = function(style){
	Zapatec.Utils.applyStyle(this.internalContainer, style);
};

/**
* Returns true if button is currently enabled
*/
Zapatec.Button.prototype.isEnabled = function(){
	return this.enabled;
};

/**
* Enable button
*/
Zapatec.Button.prototype.enable = function(){
	this.enabled = true;

	this.toggleClass("mouseOut");
};

/**
* Disable button
*/
Zapatec.Button.prototype.disable = function(){
	this.enabled = false;

	this.toggleClass("disabled");
};

/**
 * Sets the button text.
 * @param text {string} text to be set.
 */
Zapatec.Button.prototype.setText = function(text) {
	this.internalContainer.innerHTML = text;
};

/**
 * Gets the button text.
 * @return {string} button text.
 */
Zapatec.Button.prototype.getText = function() {
	return this.internalContainer.innerHTML;
};

/**
* Takes given element (input type=”image|button|submit|reset”, button, image,
* div or span) and replaces it with Zapatec.Button with given config. Original
* element will be hided.
*/
Zapatec.Button.setup = function(elRef, config){
	elRef = Zapatec.Widget.getElementById(elRef);

	if(elRef == null){
		return null;
	}

	if(config == null){
		config = {};
	}

	var nodeName = elRef.nodeName.toLowerCase();

	var oldOverAction = config.overAction != null ? config.overAction : function(){return true;};
	config.overAction = function(ev){return (
		(elRef.onmouseover != null ? elRef.onmouseover.call(ev) : true) &&
		oldOverAction(ev)
	);};

	var oldOutAction = config.outAction != null ? config.outAction : function(){return true;};
	config.outAction = function(ev){return (
		(elRef.onmouseout != null ? elRef.onmouseout.call(ev) : true) &&
		oldOutAction(ev)
	);};

	var oldDownAction = config.downAction != null ? config.downAction : function(){return true;};
	config.downAction = function(ev){return (
		(elRef.onmousedown != null ? elRef.onmousedown.call(ev) : true) &&
		oldDownAction(ev)
	);};

	var oldClickAction = config.clickAction != null ?
		config.clickAction : function(){return true;};

	config.clickAction = function(ev){return (
		(elRef.onclick != null ? elRef.onclick.call(ev) : true) &&
		oldClickAction(ev)
	);};

	var submitAction = function(ev){
		if(elRef.form != null && elRef.zpHidden == null){
			var hidden = document.createElement("input");
			hidden.type = 'hidden';
			hidden.name = elRef.name;
			hidden.value = elRef.value;
			hidden.style.display = 'none';
			Zapatec.Utils.insertAfter(elRef, hidden);
			elRef.zpHidden = hidden;
		}

		if(elRef.form && elRef.form.onSubmit != null){
			elRef.form.onSubmit();
		}

		return (
			(elRef.onclick != null ? elRef.onclick.call(ev) : true) &&
			oldClickAction(ev) &&
			(elRef.form != null ? elRef.form.submit() : true)
		);
	};

	if(nodeName == 'button'){
		config.text = elRef.value;
	} else if(nodeName == 'img'){
		config.image = elRef.src;
		config.text = elRef.title || elRef.title;
	} else if(
		nodeName == 'div' ||
		nodeName == 'span'
	){
		config.text = elRef.innerHTML;
	} else if(nodeName == 'input'){
		config.text = elRef.value;
		if(elRef.type.toLowerCase() == 'image'){
			config.image = elRef.src;
			config.clickAction = submitAction;
		} else if(elRef.type.toLowerCase() == 'button'){
		} else if(elRef.type.toLowerCase() == 'submit'){
			config.clickAction = submitAction;
		} else if(elRef.type.toLowerCase() == 'reset'){
			config.clickAction = function(ev){
				(elRef.onclick != null ? elRef.onclick.call(ev) : true) &&
				oldClickAction(ev) &&
				(elRef.form != null ? elRef.form.reset() : true)
			};
		} else {
			return null;
		}
	} else {
		return null;
	}

	var button = new Zapatec.Button(config);
	Zapatec.Utils.insertAfter(elRef, button.getContainer());
	elRef.disabled = true;
	elRef.style.display = 'none';

	return button;
};

/**
* Takes all suitable elements (input type=”image|button|submit|reset” or
* button) from elRef childs and makes Zapatec.Button.setup() for each of them.
*/
Zapatec.Button.setupAll = function(elRef, config){
	if(typeof(elRef) == 'string'){
		elRef = document.getElementById(elRef);
	}

	if(elRef == null){
		return null;
	}

	var childs = elRef.all ? elRef.all : elRef.getElementsByTagName("*");

	function cloneConfig(){
		var cfg = {};

		for(var option in config){
			cfg[option] = config[option];
		}

		return cfg;
	}

	for(var ii = 0; ii < childs.length; ii++){
		if(
			childs[ii].nodeType == 1 &&
			(
				childs[ii].nodeName.toLowerCase() == 'button' ||
				childs[ii].nodeName.toLowerCase() == 'input' &&
				(
					childs[ii].type.toLowerCase() == 'image' ||
					childs[ii].type.toLowerCase() == 'button' ||
					childs[ii].type.toLowerCase() == 'submit' ||
					childs[ii].type.toLowerCase() == 'reset'
				)
			)
		){
			Zapatec.Button.setup(childs[ii], cloneConfig());
		}
	}
};

Zapatec.Button.prototype.destroy = function(){
    this.container.onmouseover = null;
    this.container.onmouseout = null;
    this.container.onmousedown = null;
    this.container.onmouseup = null;
    this.container.onclick = null;

        
        //Zapatec.Utils.destroy(this.internalContainer)
        //Zapatec.Utils.destroy(this.statusContainer)
        //Zapatec.Utils.destroy(this.container)
	this.internalContainer = null;
	this.statusContainer = null;
	this.container = null;

	return null;
};
//$Id: zpobjects.js 6804 2007-03-30 11:43:26Z slip $
/**
 * This is a constructor for Zapatec Array.
 * It can create new array or extend the given
 * one with some useful methods. You can use
 * it with new opertaor or as simple function.
 * Here is the list of extended methods:
 *    method name   | description
 *  -------------------------------------------------------------------------------------------------
 *   clear          | empties the array and returns itself
 *   compact        | deletes the null and undefined items from resulting array
 *   indexOf        | returns the index of the item with the value pointed
 *   without        | returns array without values pointed as all arguments
 *   remove         | returns array without elements that were under poited indexes.
 *                  | You can pass arguments or you can pass an array.
 * @param arr {array} if given this array will be 
 * extended.
 * @return {array} extended array.
 */
Zapatec.Array = function(arr) {
	//if array is not given then creating new one
	if (!Zapatec.isArray(arr)) {
		var array = [];
		for(var i = 0; i < arguments.length; ++i) {
			array.push(arguments[i]);
		}
		arr = array;
	}
	//copying all internal methods to array instance.
	//clears the array
	arr.clear = function() {
		Zapatec.Array.clear(this);
	};
	//returns compact array
	arr.compact = function() {
		var compact = Zapatec.Array.compact(this);
		return Zapatec.Array(compact);
	};
	//returns index of element, otherwise -1
	arr.indexOf = function(value) {
		return Zapatec.Array.indexOf(this, value);
	};
	//returns array without some values
	arr.without = function() {
		var args = [].slice.call(arguments, 0);
		args.unshift(this);
		var without = Zapatec.Array.without.apply(Zapatec.Array, args);
		return Zapatec.Array(without);
	};
	//returns array without pointed indexes
	arr.remove = function() {
		var args = [].slice.call(arguments, 0);
		args.unshift(this);
		var cut = Zapatec.Array.remove.apply(Zapatec.Array, args);
		return Zapatec.Array(cut);
	};
	//iterates through array, first argument is iterator
	//function, second one can switch reverse iteration,
	//iterator function is passed: index, value, array
	arr.each = function(func, reverse) {
		var result;
		for(var index = reverse ? this.length - 1 : 0; 
		    reverse ? (index >= 0) : (index < this.length); 
		    reverse ? --index : ++index) {
				if (typeof func == "function") {
					result = func(index, this[index], this);
					if (result == "break") {
						break;
					}
				}
		}
		//need a way to return the break indicator
		if (result == "break") {
			return false;
		}
		return true;
	};
	//indicator of Zapatec.Array
	arr.isZpArray = true;
	
	return arr;
};

/**
 * Clears the given array from null and undefined items.
 * @param arr {array} array to compact.
 * @return {array} cleared array.
 */
Zapatec.Array.compact = function(arr) {
	var newArr = [];
	for(var item = 0; item < arr.length; ++item) {
		if (arr[item] !== null && typeof arr[item] != "undefined") {
			newArr.push(arr[item]);
		}
	}
	return newArr;
};

/**
 * Returns the empty array.
 * @param arr {array} array to clear.
 */
Zapatec.Array.clear = function(arr) {
	arr.length = 0;
};

/**
 * Returns the index of the value in the given array.
 * If value was not found returns -1.
 * @param arr {array} array to walk through.
 * @param value {mixed} value to seek for.
 * @return {number} index of found item or -1.
 */
Zapatec.Array.indexOf = function(arr, value) {
	//iterating through items
	for(var item = 0; item < arr.length; ++item) {
		if (arr[item] === value) {
			//returning found index
			return item;
		}
	}
	//returning failure.
	return -1;
};

/**
 * Returns the array without pointed items.
 * All the arguments that were passed after
 * arr will be used as values to seek.
 * @param arr {array} array to cut.
 * @return {array} array without elements which were passed.
 */
Zapatec.Array.without = function(arr) {
	var newArr = [], without;
	//iterating through items
	for(var item = 0; item < arr.length; ++item) {
		without = false;
		for(var value = 1; value < arguments.length; ++value) {
			if (arr[item] === arguments[value]) {
				//flag that we need to exclude this element
				without = true;
				break;
			}
		}
		//if not excluding lets push this value to result
		if (!without) {
			newArr.push(arr[item]);
		}
	}
	//returning array.
	return newArr;
};

/**
 * Returns the array without items that were under pointed
 * indexes. Second and next parameters are treated as indexes
 * to remove. You can also pass array of indexes as second argument.
 * @param arr {array} array to cut.
 * @return {array} array without items with pointed indexes.
 */
Zapatec.Array.remove = function(arr) {
	var newArr = [], without, value, start = 1;
	if (arguments[1] && arguments[1].length && typeof arguments[1] == "object") {
		args = arguments[1];
		start = 0;
	} else {
		args = arguments;
	}
	//iterating through items
	for(var item = 0; item < arr.length; ++item) {
		without = false;
		for(value = start; value < args.length; ++value) {
			if (item === args[value]) {
				//flag that we need to exclude this element
				without = true;
				break;
			}
		}
		//if not excluding lets push this value to result
		if (!without) {
			newArr.push(arr[item]);
		}
	}
	//returning array.
	return newArr;
};

/**
 * This is a constructor for Zapatec Hash.
 * It can create new hash or extend the given
 * one with some useful methods. You can use
 * it with new opertaor or as simple function.
 * Here is the list of extended methods:
 *    method name   | description
 *  -------------------------------------------------------------------------------------------------
 *   hashRemove     | returns hash without properties pointed as all arguments or array as an argument
 *   hashEach       | iterates through all hash pairs of key and value. Internal methods are skiped.
 *   hashIsEmpty    | returns true if hash has no items. Internal methods are not taken in account.
 *
 * @param hash {object} if given this hash will be extended.
 * @return {object} extended hash.
 */
Zapatec.Hash = function(hash) {
	//if hash is not given then creating new one
	if (!hash || typeof hash != "object") {
		hash = {};
	}
	//copying all internal methods to array instance.
	//returns hash without pointed properties
	hash.hashRemove = function() {
		var args = [].slice.call(arguments, 0);
		args.unshift(this);
		var without = Zapatec.Hash.remove.apply(Zapatec.Hash, args);
		return Zapatec.Hash(without);
	};
	//iterating through hash properties, first parameter
	//is iterator function
	hash.hashEach = function(func) {
		//flag if we should execute iteration function
		var result = null;
		//looping through all properties
		for(var prop in this) {
			//excluding Zapatec.Hash properties
			if (prop == "hashRemove" || prop == "hashEach" 
			    || prop == "hashIsEmpty" || prop == "isZpHash") {
					continue;
			}
			//excluding Object properties
			if (typeof Object.prototype[prop] != "undefined") {
				continue;
			}
			//if this is not Object or Zapatec.Hash property
			//lets call iteration function.
			result = func(prop, this[prop], this);
			if (result == "break") {
				break;
			}
		}
		//need a way to return the break indicator
		if (result == "break") {
			return false;
		}
		return true;
	};
	//checks if hash is empty
	hash.hashIsEmpty = function() {
		var empty = true;
		this.hashEach(function() {
			empty = false;
			return "break";
		});
		return empty;
	};
	//indicator of Zapatec.Hash
	hash.isZpHash = true;
	
	return hash;
};

/**
 * Returns the hash without properties which has names
 * pointed as second and other arguments.
 * You can also pass array of strings as second argument.
 * @param hash {object} hash to remove property from.
 * @return {object} cut hash.
 */
Zapatec.Hash.remove = function(hash) {
	var newHash = {}, without, value, start = 1;
	if (arguments[1] && arguments[1].length && typeof arguments[1] == "object") {
		args = arguments[1];
		start = 0;
	} else {
		args = arguments;
	}
	//iterating through items
	for(var item in hash) {
		without = false;
		for(value = start; value < args.length; ++value) {
			if (item === args[value]) {
				//flag that we need to exclude this element
				without = true;
				break;
			}
		}
		//if not excluding lets add this value to result
		if (!without) {
			newHash[item] = hash[item];
		}
	}
	//returning hash.
	return newHash;
};

/**
 * Gets the value from the hash tree by given path.
 * Path can include method calls and array indexing.
 * @param hash {object} hash to seek in.
 * @param path {string} path to the element.
 * @return {object} object with two properties:
 *                  - value - value by the path.
 *                  - result - success or failure.
 */
Zapatec.Hash.getByPath = function(hash, path) {
	//if no path - no action
	if (!path || typeof path != "string") {
		Zapatec.Log({description : "Not a path passed to Zapatec.Hash.getByPath function!", type : "warning"});
		return {
			result : false
		};
	}
	//splitting the path
	var paths = path.split(".");
	//if no items splitted then something is wrong
	if (!paths.length) {
		Zapatec.Log({description : "Wrong path passed to Zapatec.Hash.getByPath function!", type : "warning"});
		return {
			result : false
		};
	}
	//iterateing through each item
	var item = 0;
	var value = hash;
	var name = "";
	var scope = null;
	while(paths[item]) {
		//if there is still part of the path current element can not be null
		if (value === null || typeof value == "undefined") {
			Zapatec.Log({description : "Incorrect path passed to Zapatec.Hash.getByPath function!", type : "warning"});
			return {
				result : false
			};
		}
		//getting property name
		name = paths[item].replace(/(\(\)|\[[^\[\]]+\])+/, "");
		try {
			//saving the parent object as scope for its methods if there are any
			scope = value;
			//getting the property value
			value = value[name];
		} catch (e) {
			Zapatec.Log({description : "Incorrect path passed to Zapatec.Hash.getByPath function!", type : "warning"});
			return {
				result : false
			};
		}
		//taking the rest part to seek for array indexes or method execution brackets
		paths[item] = paths[item].replace(name, "");
		//cyclically getting the value by array indexes or method execution
		//there can be many of the in one property name
		while (paths[item] != "") {
			//getting first one
			name = paths[item].match(/(\(\)|\[[^\[\]]+\])/)[1];
			//if it is method lets try to execute it
			if (name && /\(\)$/.test(name)) {
				try {
					//we use parent object scope or if its not a direst method
					//but just a function we use itself as a scope
					value = value.call(scope || value);
					//scope becomes null until we get another property by name
					scope = null;
				} catch (e) {
					Zapatec.Log({description : "Incorrect path passed to Zapatec.Hash.getByPath function!", type : "warning"});
					return {
						result : false
					};
				}
			} else if (name && /\[["']?[^\[\]"']+["']?\]$/.test(name)) {// if this is an array lets take its item
				try {
					//taking the item by index
					value = value[name.match(/\[["']?([^\[\]"']+)["']?\]/)[1]];
					//scope becomes null until we get another property by name
					scope = null;
				} catch (e) {
					Zapatec.Log({description : "Incorrect path passed to Zapatec.Hash.getByPath function!", type : "warning"});
					return {
						result : false
					};
				}
			}
			//removing index or brackets from the prop path
			paths[item] = paths[item].replace(name, "");
		}
		++item;
	}
	if (typeof value == "undefined") {
		Zapatec.Log({description : "Incorrect path passed to Zapatec.Hash.getByPath function!", type : "warning"});
		return {
			result : false
		};
	}
	return {
		result : true,
		value : value
	};
};

/**
 * Sets the value to the hash tree by given path.
 * Path can include method calls and array indexing.
 * @param hash {object} hash to set in.
 * @param path {string} path to the element.
 * @param val {mixed} value to set.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Hash.setByPath = function(hash, path, val) {
	//if no path - no action
	if (!path || typeof path != "string") {
		Zapatec.Log({description : "Not a path passed to Zapatec.Hash.setByPath function!", type : "warning"});
		return false;
	}
	//splitting the path
	var paths = path.split(".");
	//if no items splitted then something is wrong
	if (!paths.length) {
		Zapatec.Log({description : "Wrong path passed to Zapatec.Hash.setByPath function!", type : "warning"});
		return false;
	}
	//taking last item in path (splitted by '.')
	var lastItem = paths[paths.length - 1];
	var obj = hash;
	//making the rest of the path available for
	//Zapatec.Hash.getByPath
	var getPath = paths.slice(0, -1).join(".");
	//if there are array indexes lets save just the last one
	//as the last item and add the rest to the getPath
	var arrIndexReg = /\[[^\[\]]+\]$/;
	if (arrIndexReg.test(lastItem)) {
		getPath += (getPath == "" ? "" : ".") + lastItem.replace(arrIndexReg, "");
		lastItem = lastItem.match(/\[["']?([^\[\]"']+)["']?\]$/)[1];
	}
	//seeking the object property of which we need to set
	if (getPath != "") {
		var obj = Zapatec.Hash.getByPath(hash, getPath).value;
	}
	//trying to set the value
	try {
		obj[lastItem] = val;
	} catch (e) {
		Zapatec.Log({description : "Incorrect path passed to Zapatec.Hash.setByPath function!", type : "warning"});
		return false;
	}
	return true;
};

/** 
 * Returns true if this is HTML element.
 * return {boolean} true if HTML element, otherwise false.
 */
Zapatec.isHtmlElement = function(el) {
	if (!el || el.nodeType != 1) {
		return false;
	}
	
	return true;
};

/**
 * Returns true if object has sizable interface.
 * return {boolean} true if sizable, otherwise false.
 */
Zapatec.isSizableObj = function(obj) {
	if (obj && obj.hasInterface && obj.hasInterface("Zapatec.Sizable")) {
		return true;
	}
	
	return false;
};

/**
 * Returns true if object has movable interface.
 * return {boolean} true if sizable, otherwise false.
 */
Zapatec.isMovableObj = function(obj) {
	if (obj && obj.hasInterface && obj.hasInterface("Zapatec.Movable")) {
		return true;
	}
	
	return false;
};

/**
 * Returns true if object is an array.
 * return {boolean} true if array, otherwise false.
 */
Zapatec.isArray = function(arr) {
	if (arr && typeof arr == "object" && arr.constructor == Array) {
		return true;
	}
	
	return false;
};

/**
 * Returns true if object is a Date object.
 * return {boolean} true if Date object, otherwise false.
 */
Zapatec.isDate = function(date) {
	if (date && typeof date == "object" && date.constructor == Date) {
		return true;
	}
	
	return false;
};

/**
 * object for saving and restoring properties of the given object - SRProp (Save Restore Object Properties)
 * @param obj [object] - object to work with
 * this class adds methods to any given object which enable to save and restore properties using following
 * \code
 *   var object = {};
 *   ob = new Zapatec.SRProp(obj);
 *   object.prop = "";
 *   ob.saveProp("prop");
 *   object.prop = "ttt";
 *	 ob.restoreProp("prop");
 *   ob.restoreAll();
 * \endcode
 */
Zapatec.SRProp = function(obj) {
	//storeing of an object to inspect
	this.obj = obj;
	//array of stored properties
	this.savedProps = new Zapatec.Hash();
	//giving the object itself the refference to SRProp obj
	Zapatec.Utils.createProperty(obj, "restorer", this);
}

/**
 * Returns the hash of the saved properties. This method can be easily
 * overwritten for extending object.
 * @return {object} object containing all saved properties.
 */
Zapatec.SRProp.prototype.getSavedProps = function() {
	return this.savedProps;
};

/**
 * Returns the object we are working with.
 * @return {object} object ot work with.
 */
Zapatec.SRProp.prototype.getObject = function() {
	return this.obj;
};

/**
 * Saves the named property to savedProp array
 * You should not overwrite this method as it is core of the object.
 * @param propName [string] - name of the property to save - can be the followin "prop", "level1.level2" and so on.
 * @return true if successful, otherwise false
 */
Zapatec.SRProp.prototype.saveProp = function (propName) {
	//property name should definately be string, I think :)
	if (typeof propName != "string") {
		return false;
	}
	//getting the value of the property
	var value = Zapatec.Hash.getByPath(this.getObject(), propName);
	//checking if method doesn't failed
	if (value.result) {
		if (typeof this.getProp(propName) != "undefined") {
			var prop = this.getSavedProps()[propName] = Zapatec.Array(this.getSavedProps()[propName]);
			prop.push(value.value);
			prop.combination = true;
			Zapatec.Log({description : "The property '" + propName + "' now contains more than one value!", type : "warning"});
		} else {
			//if not saving value to the table
			this.getSavedProps()[propName] = value.value;
		}
		//returning success
		return true;
	} else {
		//returning failure
		return false;
	}
}

/**
 * Saves the named properties to savedProp array
 * You should not overwrite this method as it is core of the object.
 * @param can be any set of params, but only strings will be parsed.
 * @return an array of saved properties names
 */
Zapatec.SRProp.prototype.saveProps = function () {
	//this array will store a set of really saved properties
	var result = [];
	for(var i = 0; i < arguments.length; ++i) {
		if (this.saveProp(arguments[i])) {
			//if saved successfuly lets push propety name
			//to result array.
			result.push(arguments[i]);
		}
	}
	return result;
}

/**
 * Restores the named property from savedProp array.
 * You should not overwrite this method as it is core of the object.
 * @param propName [string] - name of the property to restore - can be the followin "prop", "level1.level2" and so on.
 * @return true if successful, otherwise false
 */
Zapatec.SRProp.prototype.restoreProp = function (propName) {
	//property name should definately be string, I think :)
	if (typeof propName != "string" || typeof this.getSavedProps()[propName] == "undefined") {
		return false;
	}
	var prop = this.getSavedProps()[propName];
	var combination = false, nextSibling = null;
	if (Zapatec.isArray(prop) && prop.combination) {
		prop = prop[prop.length - 1];
		combination = true;
	}
	//Its a workaround for HTML properties such as parentNode to be handled correctly
	if (propName.match(/parentNode$/) !== null && prop && typeof prop == "object" && prop.appendChild) {
		nextSibling = this.getSavedProps()[propName.replace(/parentNode/, "nextSibling")] || null;
		if (nextSibling && nextSibling.parentNode == prop) {
			prop.insertBefore(this.getObject(), nextSibling);
		} else {
			prop.appendChild(this.getObject());
		}
		//removing nextSibling property.
		this.savedProps = this.getSavedProps().hashRemove(propName.replace(/parentNode/, "nextSibling"));
	} else {
		//restoreing property
		if (!Zapatec.Hash.setByPath(this.getObject(), propName, prop)) {
			return false;
		}
	}
	//and now free the position in the hash as the property was restored
	if (!combination) {
		this.savedProps = this.getSavedProps().hashRemove(propName);
	} else {
		prop = this.getSavedProps()[propName];
		this.getSavedProps()[propName] = Zapatec.Array.without(prop, prop.length - 1);
	}
	
	return true;
}

/**
 * Restores the named properties from savedProp array
 * You should not overwrite this method as it is core of the object.
 * @param can be any set of params, but only strings will be parsed.
 * @return true if successful, otherwise false
 */
Zapatec.SRProp.prototype.restoreProps = function (propName) {
	//this array will store a set of really restored properties
	var result = [];
	for(var i = 0; i < arguments.length; ++i) {
		if (this.restoreProp(arguments[i])) {
			//if restored successfuly lets push propety name
			//to result array.
			result.push(arguments[i]);
		}
	}
	return result;
}

/**
 * Restores all properties from the savedProp array
 * You should not overwrite this method as it is core of the object.
 */
Zapatec.SRProp.prototype.restoreAll = function() {
	//just iterating through all saved proerties and restoreing them
	var self = this;
	this.getSavedProps().hashEach(function(i) {
		self.restoreProp(i);
	});
}

/**
 * Gets property value by name from the savedProp array
 * You should not overwrite this method as it is core of the object.
 * @param propName [string] - name of the property to get - can be the followin "prop", "level1.level2" and so on.
 */
Zapatec.SRProp.prototype.getProp = function(propName) {
	//Should I expalin this? :)
	return this.getSavedProps()[propName];
}

/**
 * Checks if hash of saved properties is empty.
 * @return {boolean} true if there are no saved properties,
 * otherwise false.
 */
Zapatec.SRProp.prototype.isEmpty = function() {
	return this.getSavedProps().hashIsEmpty();
};

/**
 * Destroys an object.
 */
Zapatec.SRProp.prototype.destroy = function() {
	//destroing cross-reference
	this.getObject().restorer = null;
	//deleteing each property of the object
	for(var iProp in this) {
		this[iProp] = null;
	}
	
	return null;
};

/**
 * Command event interface. It lets you controll
 * the listeners execution, like stoping, re-executing.
 * It is thought that implementing object inherits
 * Zapatec.EventDriven.
 */
Zapatec.CommandEvent = {};

/**
 * New fireEvent method to fit new functionality.
 * @param strEvent [string] - event name.
 */
Zapatec.CommandEvent.fireEvent = function(strEvent) {
	//checking if there is such event
	if (!this.events[strEvent]) {
		return;
	}
	//getting listeners
	var arrListeners = this.events[strEvent].listeners.slice();
	//clearing previously returned value
	this._setReturnedValue(null);
	//enabling event propogation.
	this._setEventPropagation(true);
	for (var iListener = 0; iListener < arrListeners.length; iListener++) {
		// Remove first argument
		var arrArgs = [].slice.call(arguments, 1);
		// Call in scope of this object
		arrListeners[iListener].apply(this, arrArgs);
		//getting the returned result
		var result = this._getReturnedValue();
		//if needed we stop propogation
		if (!this._getEventPropagation()) {
			return result;
		}
		//proceeding the returned value
		if (result == "re-execute") {
			this.fireEvent(strEvent);
			break;
		} else if (result == "parent-re-execute") {
			return result;
		}
	}
	//returning value
	return this._getReturnedValue();
};

/**
 * This method can be used by listeners to return some value.
 * @param val {mixed} any value to return.
 */
Zapatec.CommandEvent.returnValue = function(val) {
	this._setReturnedValue(val);
};

/**
 * Sets returned value to internal variable.
 * @param val {mixed} value to set.
 */
Zapatec.CommandEvent._setReturnedValue = function(val) {
	this.returnedValue = val;
};

/**
 * Gets returned value from internal variable.
 * @return {mixed} value.
 */
Zapatec.CommandEvent._getReturnedValue = function() {
	return this.returnedValue;
};

/**
 * Stops the chain of execution of event listenrs.
 */
Zapatec.CommandEvent.stopPropagation = function() {
	this._setEventPropagation(false);
};

/**
 * Saves propgation state to internal variable.
 * @param on {boolean} true to turn on, false to turn off.
 */
Zapatec.CommandEvent._setEventPropagation = function(on) {
	this.eventPropagation = on;
};

/**
 * Gets propgation state from internal variable.
 * @return {boolean} true if turned on, otherwise false.
 */
Zapatec.CommandEvent._getEventPropagation = function() {
	return this.eventPropagation;
};

/**
 * The object working with global controlled events.
 */
Zapatec.GlobalEvents = new Zapatec.EventDriven();
Zapatec.implement(Zapatec.GlobalEvents, "Zapatec.CommandEvent");
Zapatec.GlobalEvents.init();//$Id: dom.js 6804 2007-03-30 11:43:26Z slip $
/**
 * Gets the width of the HTML element. This
 * is used to take out the measurement of sizing.
 * Currently offset measurement is used, cause
 * its equal for different box sizings.
 * @param el {HTML element} element to get width of.
 * @return {number} the measurement width of the element,
 * if not HTML element then false.
 */
Zapatec.Utils.getWidth = function(el) {
	//checking for valid element type
	if (!Zapatec.isHtmlElement(el)) {
		return false;
	}
	//returning the width
	return el.offsetWidth
};

/**
 * Gets the height of the HTML element. This
 * is used to take out the measurement of sizing.
 * Currently offset measurement is used, cause
 * its equal for different box sizings.
 * @param el {HTML element} element to get height of.
 * @return {number} the measurement height of the element,
 * if not HTML element then false.
 */
Zapatec.Utils.getHeight = function(el) {
	//checking for valid element type
	if (!Zapatec.isHtmlElement(el)) {
		return false;
	}
	//returning the height
	return el.offsetHeight
};

/**
 * Sets the width of the HTML element. This is
 * cross-browser implementation that is based on
 * Zapatec.Utils.getWidth value for this element. 
 * @param el {HTML element} element to set width.
 * @param width {number} width to set.
 * @return {boolean} true if width set, otherwise false.
 */
Zapatec.Utils.setWidth = function(el, width) {
	//getting integer value
	width = Math.round(width);
	//checking for valid element type and valid width
	if (!Zapatec.isHtmlElement(el) || width <= 0) {
		return false;
	}
	//saving old style width to restore if fail
	var oldWidth = el.style.width, newWidth;
	//trying to set width (first try)
	el.style.width = width + "px";
	//checking if it was set correctly
	if (Zapatec.Utils.getWidth(el) != width) {
		//if not lets try to calculate correct value
		newWidth = width - (Zapatec.Utils.getWidth(el) - width);
		if (newWidth > 0) {
			//and if its a valid number for size let's try again to set it
			el.style.width = newWidth + "px";
			//if still wrong result we need to restore old size,
			//report the warning and return false
			if (Zapatec.Utils.getWidth(el) != width) {
				el.style.width = oldWidth;
				Zapatec.Log({description : "Can't set the width - " + width + "px!", type : "warning"});
				return false;
			}
		} else {
			//if number isn't valid we need to restore old size,
			//report the warning and return false
			el.style.width = oldWidth;
			Zapatec.Log({description : "Can't set the width - " + width + "px!", type : "warning"});
			return false;
		}
	}
	//returning success
	return true;
};

/**
 * Sets the height of the HTML element. This is
 * cross-browser implementation that is based on
 * Zapatec.Utils.getHeight value for this element. 
 * @param el {HTML element} element to set height.
 * @param width {number} height to set.
 * @return {boolean} true if height set, otherwise false.
 */
Zapatec.Utils.setHeight = function(el, height) {
	//getting integer value
	height = Math.round(height);
	//checking for valid element type and valid height
	if (!Zapatec.isHtmlElement(el) || height <= 0) {
		return false;
	}
	//saving old style height to restore if fail
	var oldHeight = el.style.height, newHeight;
	//trying to set height (first try)
	el.style.height = height + "px";
	//checking if it was set correctly
	if (Zapatec.Utils.getHeight(el) != height) {
		//if not lets try to calculate correct value
		newHeight = height - (Zapatec.Utils.getHeight(el) - height);
		if (newHeight > 0) {
			//and if its a valid number for size let's try again to set it
			el.style.height = newHeight + "px";
			//if still wrong result we need to restore old size,
			//report the warning and return false
			if (Zapatec.Utils.getHeight(el) != height) {
				el.style.height = oldHeight;
				Zapatec.Log({description : "Can't set the height - " + height + "px!", type : "warning"});
				return false;
			}
		} else {
			//if number isn't valid we need to restore old size,
			//report the warning and return false
			el.style.height = oldHeight;
			Zapatec.Log({description : "Can't set the height - " + height + "px!", type : "warning"});
			return false;
		}
	}
	//returning success
	return true;
};

/**
 * Fixates the width of HTML element in pixels.
 * @param el {HTML element} element to fixate width of.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Utils.fixateWidth = function(el) {
	return Zapatec.Utils.setWidth(el, Zapatec.Utils.getWidth(el));
};

/**
 * Fixates the height of HTML element in pixels.
 * @param el {HTML element} element to fixate height of.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Utils.fixateHeight = function(el) {
	return Zapatec.Utils.setHeight(el, Zapatec.Utils.getHeight(el));
};

/**
 * Makes some routines to make element correctly sizable.
 * This is mostly preserving sizes and making overflow
 * "hidden" or "scroll" (depends on "scrollable" parameter).
 * @param el {HTML element} element to make safely sizable.
 * @param restorer {object} Zapatec.SRProp object.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Utils.makeSafelySizable = function(el, restorer) {
	if (el.sizable) {
		return true;
	}
	//checking if HTML element was passed
	if (!Zapatec.isHtmlElement(el)) {
		return false;
	}
	//trying to take the exsistant restorer
	if (!restorer) {
		restorer = el.restorer;
	}
	//checking for restorer, if there is no or the one given won't do
	//we create new one
	if (!restorer || !restorer.getObject || restorer.getObject() != el) {
		restorer = new Zapatec.SRProp(el);
	}
	//saving properties that will be changed
	restorer.saveProps("style.width", "style.height", "style.overflow");
	//fixateing sizes
	Zapatec.Utils.fixateWidth(el);
	Zapatec.Utils.fixateHeight(el);
	//getting overflow to know if we are sizing correct
	var overflow = Zapatec.Utils.getStyleProperty(el, "overflow");
	if (overflow == "" || overflow == "visible") {
		Zapatec.Log({description : "There is the chance that this element with overflow visible will not be sized correctly!", type : "warning"});
	}
	el.sizable = true;
	
	return true;
};

/**
 * Restores the element of sizing, if it was prepared
 * by Zapatec.Utils.makeSafelySizable function.
 * @param el {HTML element} element to restore.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Utils.restoreOfSizing = function(el) {
	//checking if something was saved
	if (!el || !el.restorer || !el.sizable) {
		return false;
	}
	//restoreing needed properties
	el.restorer.restoreProps("style.width", "style.height", "style.overflow");
	if (el.restorer.isEmpty()) {
		el.restorer.destroy();
	}
	el.sizable = false;
	
	return true;
};

/**
 * Prepares elelement to be safely moved by Zapatec.Utils.moveTo. To be moved element should be positioned 
 * absolute and should be direct child of within parameter, should have margin set to 0px.
 * @param el {HTML element} the element to move
 * @param within {HTML element} if you want to move the element within some other element, 
 * @param restorer {SRProp object} the SRProp object you want to use to restore our 
 * elements properties, if you have already one.
 * pass the refference to it through this var (default is document.body)
 * @return {boolean} true if success, otherwise false
 */
Zapatec.Utils.makeSafelyMovable = function(el, within, restorer) {
	//Checking if the element is of the right type
	if (!Zapatec.isHtmlElement(el)) {
		return false;
	}
	//take default within element
	if (!within) {
		within = document.body;
	}
	//maybe element is already prepared
	if (el.within == within) {
		return true;
	}
	//trying to take the exsistant restorer
	if (!restorer) {
		restorer = el.restorer;
	}
	//checking for restorer and creating new one if existing does not 
	//fit our needs
	if (!restorer || !restorer.getObject || restorer.getObject() != el) {
		restorer = new Zapatec.SRProp(el);
	} 
	//To make it work we need the 'within' to be positioned relatively
	//except it is BODY (which means screen)
	el.within = within;
	if (within != document.body && within.style.position != "absolute") {
		restorer.saveProp("within.style.position");
		within.style.position = "relative";
	}
	//Need to preserve elements position after we prepare it for move
	if (within != document.body) {
		var pos1 = Zapatec.Utils.getElementOffset(within);
	} else {
		var pos1 = {x : 0, y : 0};
	}
	var pos2 = Zapatec.Utils.getElementOffset(el);
	var x = pos2.x - pos1.x;
	var y = pos2.y - pos1.y;
	restorer.saveProps("style.left", "style.top");
	el.style.left = x + "px";
	el.style.top = y + "px";
	//Checks if the element is positioned absolute.
	if (el.style.position != "absolute") {
		restorer.saveProp("style.position");
		el.style.position = "absolute";
	}
	//withon should be direct parent of the draggable element
	if (el.parentNode != within) {
		restorer.saveProps("parentNode", "nextSibling");
		within.appendChild(el);
	}
	//element must have margin 0px.
	restorer.saveProp("style.margin");
	el.style.margin = "0px";
	
	return true;
};

/**
 * Moves elelement to the specified position. To be moved element should be positioned absolute 
 * and should be direct child of 'within' element. If there is no el.within property, 
 * document.body will be taken. If you want safe move use Zapatec.Utils.makeSafelyMovable.
 * @param el {HTML element} - the element to move
 * @param x {number} - the x coordinate to move to
 * @param y {number} - the y coordinate to move to
 * @return {boolean} true if success, otherwise false
 */
Zapatec.Utils.moveTo = function(el, x, y) {
	//Checking if the element is of the right type
	if (!Zapatec.isHtmlElement(el)) {
		return false;
	}
	var pos = null;
	if (Zapatec.FixateOnScreen.isRegistered(el)) {
		pos = Zapatec.FixateOnScreen.correctCoordinates(x, y);
		if (Zapatec.is_ie && !Zapatec.is_ie7) {
			el.style.setExpression("left", pos.x);
			el.style.setExpression("top", pos.y);
			return true;
		}
	} else {
		pos = {
			x : parseInt(x, 10) + "px", 
			y : parseInt(y, 10) + "px"
		};
	}
	//setting of coordinates
	if (x || x === 0) {
		el.style.left = pos.x;
	}
	if (y || y === 0) {
		el.style.top = pos.y;
	}
	
	return true;
};

/** 
 * Gets the element position within another one (this depends on your implementation). 
 * @param el {HTML element} - we are getting the position of this element
 * @return {object} object with x and y properties or false if failed.
 */
Zapatec.Utils.getPos = function(el) {
	//Checking if the element is of the right type
	if (!Zapatec.isHtmlElement(el)) {
		return false;
	}
	var pos = null;
	if (pos = Zapatec.FixateOnScreen.parseCoordinates(el)) {
		return pos;
	}
	//parsing coordinates
	return {
		x : el.offsetLeft,
		y : el.offsetTop
	}
};

/**
 * Moves element by the given offset in the 'within' element.
 * @param el {HTML element} - element to move
 * @param offsetX {number} - x offset to move for
 * @param offsetY {number} - y offset to move for
 * @return {boolean} true if succeeds, otherwise false
 */
Zapatec.Utils.moveFor = function(el, offsetX, offsetY) {	
	//getting current position
	var oldPos = Zapatec.Utils.getPos(el);
	//assigning the offset
	if (oldPos) {
		return Zapatec.Utils.moveTo(el, oldPos.x + offsetX, oldPos.y + offsetY);
	} else {
		return false;
	}
};

/**
 * Restores all the changes made in the elelement by Zapatec.Utils.makeSafelyMovable. 
 * @param el {HTML element} - the element to restore
 * @return {boolean} true if successful, otherwise false
 */
Zapatec.Utils.restoreOfMove = function(el) {
	if (!el.within) return false;
	//restoreing properies if everything is okay
	el.restorer.restoreProps(
		"style.position",
		"parentNode",
		"style.margin",
		"nextSibling",
		"within.style.position",
		"style.left",
		"style.top"
	);
	if (el.restorer.isEmpty()) {
		el.restorer.destroy();
	}
	el.within = null;
	return true;
};

/**
 * returns array of elements which has attribute 'attr' with value 'val'
 * by giving 'el' you can finetune your search
 * @param attribute {string} attribute to search
 * @param value {mixed} searched attributes value.
 * @param within {HTML element} reference to the element.
 * @param recursive {boolean} searches in childs.
 * @param match {boolean} if true and attribute is string,
 * tries to seek within it.
 * @return {array} array of elements found.
 */
Zapatec.Utils.getElementsByAttribute = function(attribute, value, within, recursive, match){
	//no attributte to seek - no action
	if (!attribute) {
		return false;
	}
	//trying to get element within what we need to search
	within = Zapatec.Widget.getElementById(within);
	//if none given taking document.body
	within || (within = document.body);
	//iterating through all the elements childs
	var element = within.firstChild; result = [];
	while (element) {
		//element has attribute???
		if (element[attribute]) {
			//than if there's no value passed or values match adding it to resulting array
			if (typeof value == "undefined" || element[attribute] == value) {
				result.push(element);
			} else if (match && typeof element[attribute] == "string" && element[attribute].indexOf(value) != -1) {
				result.push(element);
			}
		};
		//if recursive, going through all the childs
		if (recursive && element.hasChildNodes()) {
			result = result.concat(Zapatec.Utils.getElementsByAttribute(attribute, value, element, recursive, match));
		}
		//taking next sibling
		element = element.nextSibling
	};
	//returning result
	return Zapatec.Array(result);
};

/**
 * Creates an instance of object using passed
 * constructor, for each element in array.
 * The element will be passed as a "container"
 * option by default, but you can redefine
 * it using parameter configOption. Using
 * third parameter you can pass other config
 * options for the constructor.
 * @param constructor {function} constructor function.
 * @param elements {array} array of elements that the
 * consstructor will be apllied to.
 * @param config {object} config obect for constructor.
 * @param configOption {string} config option that will
 * be filled with the element, default is "container".
 * @return {array} array of created widgets.
 */
Zapatec.Utils.applyToElements = function(constructor, elements, config, configOption) {
	if (typeof constructor != "function" || !Zapatec.isArray(elements)) {
		return false;
	}
	elements = Zapatec.Array(elements);
	if (!configOption) {
		configOption = "container";
	}
	//correcting or creating config object
	if (!config || typeof config != "object") {
		config = {};
	}
	//resulting array of Zapoatec.Utils.Draggable objects
	var result = Zapatec.Array();
	elements.each(function(index, element) {
		//filling config with current element
		config[configOption] = element;
		//saving resulting object
		result.push(new constructor(config));
	});
	//returning result
	return result;
};

/**
 * Replaces the image with DIV element, and sets the image as background-image.
 * this is not good for images with changed size, because you cant change the background-image size and it will tile.
 * @param el {HTML element} reference to the element.
 * @return {HTML element} the needed element.
 */
Zapatec.Utils.img2div = function(el){
	if (!Zapatec.isHtmlElement(el)) {
		return null;
	}
	//FIX ME: maybe this can be changed to div/img from just div with background
	if ((/img/i).test(el.nodeName)) {
		var div = document.createElement('div');
	    // Set div width and height when image is loaded
	    var objImage = new Image();
	    objImage.onload = function() {
	      div.style.width = this.width + 'px';
	      div.style.height = this.height + 'px';
	      div.style.fontSize = '0px';
	      this.onload = null;
	    };
	    objImage.src = el.src;
	    // Replace image with the div
	    div.style.backgroundImage = 'url(' + el.src + ')';
	    div.style.backgroundColor = 'transparent';
		var id = el.id;
		var className = el.className;
		el.parentNode.replaceChild(div, el);
		div.id = id;
		div.className = className;
		return div
	} else {
		return el
	}
};

/**
 * Returns the string with numbers representing 
 * the path in the DOM tree from the element 
 * passed as parent to the element you need.
 * Example - "1-3-1-8".
 * @param element {HTML element} element to get path of.
 * @param parent {HTML element} we stop on this element.
 * @return {string} string representing path.
 */
Zapatec.Utils.getElementPath = function(element, parent) {
	//there always should be parameters passed
	if (!Zapatec.isHtmlElement(element) || !Zapatec.isHtmlElement(parent)) {
		return false;
	}
	//array of numbers from path
	var res = [];
	var el = element;
	//going up the tree and counting previous siblings
	while(el && el != parent) {
		//at first we think that this is the first node :)
		var number = 1;
		//counting previous siblings
		while(el.previousSibling) {
			++number;
			el = el.previousSibling;
		}
		//adding a number in the beggining of the array
		res.unshift(number);
		//taking parent node
		el = el.parentNode;
	}
	//joining the resulting array to have a string value.
	return res.join("-");
};

//This is an HTML element used as a cover to imitate mousemove action correctly.
Zapatec.Utils.cover = Zapatec.Utils.createElement("div");
Zapatec.Utils.cover.style.overflow = "hidden";
//This is the workaround for IE who doesn't firest needed events if the element is empty
Zapatec.Utils.cover.style.backgroundImage = "url(" + Zapatec.zapatecPath + "zpempty.gif)";
Zapatec.Utils.cover.style.display = "none";
Zapatec.Utils.cover.id = "zpCoverControl";

/**
 * Shows the cover.
 * @param zIndex {number} - z-index of the cover.
 * @param cursor {string} - cursor to be assigned.
 * @param mouseMoveHandler {function} - handler function for mouse move
 * @param mouseUpHandler {function} - handler function for mouse up
 */
Zapatec.Utils.cover.show = function(zIndex, cursor, mouseMoveHandler, mouseUpHandler) {
	if (!this.parentNode) {
		document.body.appendChild(this);
	}
	if (this.style.display != "none") {
		this.hide();
	}
	this.style.display = "block";
	//formatting it to be over all the others(even our draggable element)
	Zapatec.Utils.makeSafelyMovable(this, null, document.body);
	//initial position
	var x = 0;
	var y = 0;
	//need to correct it with window scrolling
	y += Zapatec.Utils.getPageScrollY();
	x += Zapatec.Utils.getPageScrollX();
	//moving cover
	Zapatec.Utils.moveTo(this, x, y);
	//setting sizes
	var dim = Zapatec.Utils.getWindowSize();
	this.style.width = dim.width + "px";
	this.style.height = dim.height + "px";
	//registering it to scroll
	Zapatec.FixateOnScreen.register(this);
	//setting proper cursor and z-index
	this.style.zIndex = zIndex;
	this.style.cursor = cursor;
	//adding event listeners
	if (typeof mouseMoveHandler == "function") {
		Zapatec.Utils.addEvent(this, 'mousemove', mouseMoveHandler);
	}
	if (typeof mouseUpHandler == "function") {
		Zapatec.Utils.addEvent(this, 'mouseup', mouseUpHandler);
	}
	//saving references to the event hanlers to remove them on hide.
	this.mouseMoveHandler = mouseMoveHandler;
	this.mouseUpHandler = mouseUpHandler;
};

/**
 * Hides the cover.
 */
Zapatec.Utils.cover.hide = function() {
	//unregistering cover from being scrolled with window
	Zapatec.FixateOnScreen.unregister(this);
	//removing event handlers
	if (typeof this.mouseMoveHandler == "function") {
		Zapatec.Utils.removeEvent(this, 'mousemove', this.mouseMoveHandler);
	}
	if (typeof this.mouseUpHandler == "function") {
		Zapatec.Utils.removeEvent(this, 'mouseup', this.mouseUpHandler);
	}
	//mouse move handler
	this.mouseMoveHandler = null;
	this.mouseUpHandler = null;
	//clearing the cursor and z-index
	this.style.zIndex = "";
	this.style.cursor = "";
	//hiding elements
	this.style.display = "none";
};
//$Id: movable.js 6834 2007-04-02 06:49:19Z slip $
/**
 * This is a set of functionality used for moving object
 * and is implemented in interface (mixin) manner.
 */
Zapatec.Movable = {};

/**
 * Moves the object ot specified position.
 * Object can consist of group of elements,
 * that will be moved together. This method can
 * recognize not only "px" values, but "left", "top",
 * "bottom", "right", etc. This depends on your
 * _parseCoordinate implementation, if you don't
 * want to use standart one.
 * @param x {number or string} X coordinate.
 * @param y {number or string} Y coordinate.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Movable.setPosition = function(x, y) {
	//preparations which can depend on the Widget.
	if (!this.isMovableSafely()) {
		Zapatec.Log({description : "The object with ID '" + this.id + "' was not prepared for moving! Use obj.makeMovable() to do so!", type : "warning"});
		return false;
	}
	var msgValue = null, moveConfig = this.getMoveConfig();
	//_parseCoordinate takes the coordinate value and first of all
	//tryes to return the numeric representation in pixels.
	//Also if it returns null value (false and "" are also
	//treated so) method stops execution without making something.
	//This can be useful for implementing restrictions.
	if (x || x === 0) {
		msgValue = x;
		x = this._parseCoordinate(x, "x", moveConfig.moveLayer);
		if (!x && x !== 0) {
			Zapatec.Log({description : "The X coordinate " + msgValue + " can not be set for object with ID '" + this.id + "'!", type : "warning"});
			return false;
		}
	}
	if (y || y === 0) {
		msgValue = y;
		y = this._parseCoordinate(y, "y", moveConfig.moveLayer);
		if (!y && y !== 0) {
			Zapatec.Log({description : "The Y coordinate " + msgValue + " can not be set for object with ID '" + this.id + "'!", type : "warning"});
			return false;
		}
	}
	//getMovableElements returns the array of elements
	//that actually are moved. Param passed is the dimension 
	//in which we move.
	var elements = Zapatec.Array(this.getMovableElements());
	if (this.fireEvent("beforePositionChange", x, y) === false) {
		return false;
	}
	if (Zapatec.GlobalEvents.fireEvent("beforePositionChange", x, y, this) === false) {
		return false;
	}
	//proceeding coordinates
	this._proceedElementsCoords(x, y, elements);
	//firing events
	if (this.isMoving()) {
		this.fireEvent("onMove", x || this.getPosition().x, y || this.getPosition().y);
		Zapatec.GlobalEvents.fireEvent("onMove", x || this.getPosition().x, y || this.getPosition().y, this);
	}
	this.fireEvent("onPositionChange", x || this.getPosition().x, y || this.getPosition().y);
	Zapatec.GlobalEvents.fireEvent("onPositionChange", x || this.getPosition().x, y || this.getPosition().y, this);
	//reporting success
	return true;
};

/**
 * This method is used for the objects that use
 * such concept as orientation. Method reacts on
 * two types of orientation: "vertical" and "horizontal".
 * @param x {number} oriented X to set.
 * @param y {number} oriented Y to set.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Movable.setOrientedPosition = function(x, y) {
	switch (this.getMoveConfig().orientation) {
		case "vertical" : {
			//vertical orientation means height
			return this.setPosition(y, x);
		}
		case "horizontal" : {
			//horizontal orientation means width
			return this.setPosition(x, y);
		}
	}
	return false;
};

/**
 * Sets the position of the object relatively
 * to the document page(BODY).
 * @param x {number or string} X coordinate on the page.
 * @param y {number or string} Y coordinate on the page.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Movable.setPagePosition = function(x, y) {
	var moveConfig = this.getMoveConfig();
	if (moveConfig.moveLayer == document.body) {
		return this.setPosition(x, y);
	}
	var msgValue = null;
	//_parseCoordinate takes the coordinate value and first of all
	//tryes to return the numeric representation in pixels.
	//Also if it returns null value (false, "", 0 are also
	//treated so) method stops execution without making something.
	//This can be useful for implementing restrictions.
	if (x || x === 0) {
		msgValue = x;
		x = this._parseCoordinate(x, "x", document.body);
		if (!x && x !== 0) {
			Zapatec.Log({description : "The X page coordinate " + msgValue + " can not be set for object with ID '" + this.id + "'!", type : "warning"});
			return false;
		}
	}
	if (y || y === 0) {
		msgValue = y;
		y = this._parseCoordinate(y, "y", document.body);
		if (!y && y !== 0) {
			Zapatec.Log({description : "The Y page coordinate " + msgValue + " can not be set for object with ID '" + this.id + "'!", type : "warning"});
			return false;
		}
	}
	var pos = Zapatec.Utils.getElementOffset(moveConfig.moveLayer);
	return this.setPosition((x || x === 0) ? (x - pos.x) : x, (y || y === 0) ? (y - pos.y) : y);
};

/**
 * Sets the position of the object relatively
 * to the client area of the browser.
 * @param x {number or string} X coordinate on the screen.
 * @param y {number or string} Y coordinate on the screen.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Movable.setScreenPosition = function(x, y) {
	var moveConfig = this.getMoveConfig();
	var msgValue = null;
	//_parseCoordinate takes the coordinate value and first of all
	//tryes to return the numeric representation in pixels.
	//Also if it returns null value (false, "", 0 are also
	//treated so) method stops execution without making something.
	//This can be useful for implementing restrictions.
	if (x || x === 0) {
		msgValue = x;
		x = this._parseCoordinate(x, "x", window);
		if (!x && x !== 0) {
			Zapatec.Log({description : "The X screen coordinate " + msgValue + " can not be set for object with ID '" + this.id + "'!", type : "warning"});
			return false;
		}
	}
	if (y || y === 0) {
		msgValue = y;
		y = this._parseCoordinate(y, "y", window);
		if (!y && y !== 0) {
			Zapatec.Log({description : "The Y screen coordinate " + msgValue + " can not be set for object with ID '" + this.id + "'!", type : "warning"});
			return false;
		}
	}
	if (moveConfig.moveLayer != document.body) {
		var pos = Zapatec.Utils.getElementOffset(moveConfig.moveLayer);
	} else {
		var pos = {x : 0, y : 0};
	}
	return this.setPosition((x || x === 0) ? (x - pos.x) : x, (y || y === 0) ? (y - pos.y) : y);
};

/**
 * Moves the object for the given offset from
 * the place it is currently in.
 * @param offsetLeft {number} the offset value for X coordinate.
 * @param offsetTop {number} the offset value for Y coordinate.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Movable.moveFor = function(offsetLeft, offsetTop) {
	var pos = this.getPosition();
	return this.setPosition(
		offsetLeft == null ? null : pos.x + offsetLeft, 
		offsetTop == null ? null : pos.y + offsetTop
	);
};

/**
 * Returns the position of the main element.
 * If there is no such, we take the one that is
 * the most left and top :).
 * This value is offset from movable parent.
 * @return {object} object with x and y properties.
 */
Zapatec.Movable.getPosition = function() {
	//getMovableMeasurement returns the element
	//that is the measurement of moving for all others.
	var el = this.getMovableMeasurement();
	//if we succeed with this lets return coords
	if (Zapatec.isHtmlElement(el) || 
	    (el && typeof el == "object" && typeof el.x == "number" && typeof el.y == "number")) {
			return Zapatec.Utils.getPos(el) || el;
	}
	//otherwise reporting failure
	Zapatec.Log({description : "Can't calculate position for object with ID '" + this.id + "'!", type : "warning"});
	return false;
};

/**
 * Gets the position of the element on the page.
 * @return {object} object with x and y properties.
 */
Zapatec.Movable.getPagePosition = function() {
	//getMovableMeasurement returns the element
	//that is the measurement of moving for all others.
	var el = this.getMovableMeasurement();
	//if we succeed with this lets return coords
	if (Zapatec.isHtmlElement(el) || 
	    (el && typeof el == "object" && typeof el.x == "number" && typeof el.y == "number")) {
			return Zapatec.Utils.getElementOffset(el) || el;
	}
	//otherwise reporting failure
	Zapatec.Log({description : "Can't calculate screen position for object with ID '" + this.id + "'!", type : "warning"});
	return false;
};

/**
 * Gets the position of the element on the screen.
 * @return {object} object with x and y properties.
 */
Zapatec.Movable.getScreenPosition = function() {
	//getting page position
	var pos = this.getPagePosition();
	//excluding scrolling
	pos.x -= Zapatec.Utils.getPageScrollX();
	pos.y -= Zapatec.Utils.getPageScrollY();
	//returning position
	return pos;
};

/**
 * Strats the event of moving. This is used
 * to send message to interested objects that
 * moving was started. This involves the calling
 * of "onMove" event from setPosition.
 * endMove method stops the action.
 * @return {boolean} true if success, otherwise false
 */
Zapatec.Movable.startMove = function() {
	//preparations which can depend on the Widget.
	if (!this.isMovableSafely()) {
		Zapatec.Log({description : "The object with ID '" + this.id + "' was not prepared for moving! Use obj.makeMovable() to do so!", type : "warning"});
		return false;
	}
	this.fireEvent("moveStart");
	Zapatec.GlobalEvents.fireEvent("moveStart", this);
	this._setMovingState(true);
	return true;
};

/**
 * Ends the event of moving. This is used
 * to send message to interested objects that
 * moving was ended. This stops the calling
 * of "onMove" event from setPosition.
 * @return {boolean} true if success, otherwise false
 */
Zapatec.Movable.endMove = function() {
	if (!this.isMoving()) {
		Zapatec.Log({description : "The moving for object with ID '" + this.id + "' was not started!", type : "warning"});
		return false;
	}
	this.fireEvent("moveEnd");
	Zapatec.GlobalEvents.fireEvent("moveEnd", this);
	this._setMovingState(false);
	return true;
};

/**
 * Gets the state of moving. It returns
 * true if moving was started, otherwise
 * it returns false.
 * @return {boolean} true if moving started, otherwise false
 */
Zapatec.Movable.isMoving = function() {
	return this.movingState;
};

/**
 * Sets the state of moving to true or false.
 * This is used internally and can be overwritten
 * in child classes to use another propety for the flag.
 */
Zapatec.Movable._setMovingState = function(on) {
	this.movingState = on;
};

/**
 * Is object prepared for moving.
 * Mostly you will need to redefine this method,
 * to use some other property as a flag.
 * @return {boolean} true if prepared, otherwise false.
 */
Zapatec.Movable.isMovableSafely = function() {
	return this.safelyMovable;
};

/**
 * Fills some flag with the true or false value.
 * Same flag should be used in isMovableSafely method.
 * @param on {boolean} turn on or turn of.
 */
Zapatec.Movable._setMovableSafely = function(on) {
	this.safelyMovable = on;
};

/**
 * Makes all movable elements safely movable.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Movable.makeMovable = function() {
	if (!this.hasInterface("Zapatec.CommandEvent")) {
		Zapatec.Log({description : "The object with ID '" + this.id + "' has no Zapatec.CommandEvent interface!"});
		return false;
	}
	if (this.isMovableSafely()) {
		return true;
	}
	var elements = Zapatec.Array(this.getMovableElements()), self = this,
	moveConfig = this.getMoveConfig();
	//trying to prepare each element
	success = elements.each(function(index, movable) {
		if (Zapatec.isHtmlElement(movable)) {
			//prepareing HTML elements
			if (moveConfig.preserveSizes &&
			    !Zapatec.Utils.makeSafelySizable(movable)) {
					return "break";
			}
			if (!Zapatec.Utils.makeSafelyMovable(movable, moveConfig.moveLayer)) {
				return "break";
			}
			self.createProperty(movable, "moveObj", self);
		} else if (Zapatec.isMovableObj(movable)) {
			//prepareing movable objects
			if (!movable.makeMovable()) {
				return "break";
			}
		}
	});
	//if there was failure we need roll back all the preparations
	if (!success) {
		//restoreing elements or objects
		this.restoreOfMove();
		//reporting error
		Zapatec.Log({description : "Can not make the object with ID '" + this.id + "' movable!"});
		return false;
	}
	//reporting success
	this._setMovableSafely(true);
	return true;
};

/**
 * Restoreing object of movable state.
 * @return {boolean} always returns true.
 */
Zapatec.Movable.restoreOfMove = function() {
	if (!this.isMovableSafely()) {
		return true;
	}
	//getting all movable elements
	var elements = Zapatec.Array(this.getMovableElements());
	var self = this;
	//restoreing each item
	elements.each(function(index, movable) {
		if (Zapatec.isHtmlElement(movable)) {
			Zapatec.Utils.restoreOfMove(movable);
			if (self.getMoveConfig().preserveSizes) {
				Zapatec.Utils.restoreOfSizing(movable);
			}
			movable.moveObj = null;
		} else if (Zapatec.isMovableObj(movable)) {
			movable.restoreOfMove();
		}
	}, true);
	//returning success
	this._setMovableSafely(false);
	return true;
};

/**
 * Returns the measurement element for this movable
 * object. This a generous method, and mostly will
 * be overwritten in implementing class.
 * @return {null or number or HTML element} method should return
 * null if there is no measure, or number or HTML element to 
 * calculate measurement.
 */
Zapatec.Movable.getMovableMeasurement = function() {
	return this.getContainer();
};

/**
 * Returns the configuration object for movement.
 * @return {object} configuration object.
 */
Zapatec.Movable.getMoveConfig = function() {
	return this.getConfiguration();
};

/**
 * Sets the moving configuration.
 * @param config {object} a set of new configuration.
 */
Zapatec.Movable.setMoveConfig = function(config) {
	this.reconfigure(config);
};

/**
 * Returns the array of elements to be moved in this
 * object. This a generous method, and mostly will
 * be overwritten in implementing class.
 * @return {mixed} method should return null if there is no movable 
 * elements, or array of HTML elements or Zapatec.Movable objects
 * to size them or get their size or prepare them.
 */
Zapatec.Movable.getMovableElements = function() {
	return this.getContainer();
};

/**
 * Returns container for this object.
 */
Zapatec.Movable.getContainer = function() {
	return this.getMoveConfig().container;
};

/**
 * Parses the value of the coord argument
 * to calculate the number in pixels.
 * If this method returns null or false
 * or "" or 0 nothing is done at all.
 * @param coord {string} string representation of the coord.
 * @param dimension {string} dimension in which we should parse.
 * @return {number or null} null if nothing should be done 
 * by setPosition method, otherwise returns the coordinate in pixels.
 */
Zapatec.Movable._parseCoordinate = function(coord, dimension, within) {
	switch (true) {
		case (typeof coord == "number") : {
			if (within == window) {
				coord += Zapatec.Utils["getPageScroll" + dimension.toUpperCase()]();
			}
			break;
		}
		case ((/^\d+px$/).test(String(coord))) : {
			coord = parseInt(coord, 10);
			if (within == window) {
				coord += Zapatec.Utils["getPageScroll" + dimension.toUpperCase()]();
			}
			break;
		}
		case ((/^(left|top|bottom|right|center)$/i).test(String(coord))) : {
			coord = this._parseWordCoordinate(coord, dimension, within);
			break;
		}
	}
	return this._canSetCoordinate(coord, dimension, within);
};

/**
 * Parses coordinate that is represented with one of the 
 * following words : "left", "top", "right", "bottom", "center".
 * All of the words (except center) have special meaning for
 * upper case. If lower case means top to top (left to left, etc.), 
 * then upper case means bottom to top.
 * @param coord {string} string representing coordinate.
 * @param dimension {string} dimension in which we parse.
 * @param within {HTML element} this is the basis on which we parse.
 * @return {number or false} numeric representation of the coordinate
 * or false if can not parse.
 */
Zapatec.Movable._parseWordCoordinate = function(coord, dimension, within) {
	//preventing errors
	if ((/(left|right)/i).test(String(coord)) && dimension.toUpperCase() != "X") {
		return false;
	}
	if ((/(top|bottom)/i).test(String(coord)) && dimension.toUpperCase() != "Y") {
		return false;
	}
	//additional helpfull strings to make code shorter
	var dim = (dimension.toUpperCase() == "X") ? "Left" : "Top";
	var sizeDim = (dimension.toUpperCase() == "X") ? "Width" : "Height";
	//at first leave it as zero
	var parsedCoord = 0;
	//getting needed within size for calculating coordinate
	var wSize = null;
	if (Zapatec.isHtmlElement(within)) {
		//include scrolling
		parsedCoord = within["scroll" + dim];
		//getting size
		wSize = Zapatec.Utils["get" + sizeDim](within);
	} else if (within == window) {
		//include scrolling
		parsedCoord = Zapatec.Utils["getPageScroll" + dimension.toUpperCase()]();
		//getting size
		wSize = Zapatec.Utils.getWindowSize()[sizeDim.toLowerCase()];
	} else if (within && typeof within == "object") {
		//changing coordinate
		parsedCoord += within["scroll" + dim] || 0;
		//getting size
		wSize = within[sizeDim.toLowerCase()];
	} else {
		return false;
	}
	//getting measurement
	var measurement = this.getMovableMeasurement();
	//getting needed measurement size for calculating coordinate
	var mSize = null;
	if (Zapatec.isHtmlElement(measurement)) {
		mSize = Zapatec.Utils["get" + sizeDim](measurement);
	} else if (measurement && typeof measurement == "object") {
		mSize = measurement[sizeDim.toLowerCase()];
	}
	//calculating actual coordinate
	switch (coord) {
		case "left" : case "top" : {
			break;
		}
		case "LEFT" : case "TOP" : {
			parsedCoord -= mSize;
			break;
		}
		case "right" : case "bottom" : {
			parsedCoord += wSize - mSize;
			break;
		}
		case "RIGHT" : case "BOTTOM" : {
			parsedCoord += wSize;
			break;
		}
		case "center" : {
			parsedCoord += Math.round((wSize - mSize) / 2);
			break;
		}
		case "CENTER" : {
			parsedCoord += Math.round(wSize / 2);
			break;
		}
		default : {
			parsedCoord = null;
			break;
		}
	}
	//returning result
	if (!parsedCoord && parsedCoord !== 0) {
		return false;
	} else {
		return parsedCoord;
	}
};

/**
 * This method restricts coordinate setting.
 * @param coord {string} coordinate.
 * @param dimension {string} dimension in which we check.
 * @param within {HTML element} this is the basis on which we check.
 * @return {number or false} the coordinate or false if can not set.
 */
Zapatec.Movable._canSetCoordinate = function(coord, dimension, within) {
	if (typeof coord != "number") {
		return false;
	}
	//getting move configuration
	var moveConfig = this.getMoveConfig();
	//we don't check for other withins than moveLayer
	if (within != moveConfig.moveLayer) {
		return coord;
	}
	//getting limit object
	var limitObj = moveConfig.limit;
	//coordinate dimension ("X" or "Y") to be used for getting values
	var dim = dimension.toUpperCase();
	//direction of possible movement
	var direction = moveConfig.direction.toLowerCase();
	//getting corrections to restriction due to moving shape
	var correction = this._getMovableShape();
	//if dimension is opposite to possible direction of movement
	//returning overflow handling
	if (dim == "X" && direction == "vertical") {
		return this._handleCoordOverflow(this.getPosition().x);
	} else if (dim == "Y" && direction == "horizontal") {
		return this._handleCoordOverflow(this.getPosition().y);
	}
	//checking the lower bound
	if ((limitObj["min" + dim] || limitObj["min" + dim] === 0) && coord < limitObj["min" + dim] + correction["min" + dim]) {
		return this._handleCoordOverflow(limitObj["min" + dim] + correction["min" + dim]);
	}
	//checking the upper bound
	if ((limitObj["max" + dim] || limitObj["max" + dim] === 0) && coord > limitObj["max" + dim] + correction["max" + dim]) {
		return this._handleCoordOverflow(limitObj["max" + dim] + correction["max" + dim]);
	}
	//just returning value
	return coord;
};

/**
 * A method to handle coordinate overflow of the limit.
 * @param limit {number} limit that was overflowed.
 * @param dimension {string} dimension of coordinate.
 * @return {boolean or number} false if can not set,
 * otherwise new coordinate.
 */
Zapatec.Movable._handleCoordOverflow = function(limit, dimension) {
	return false;
};

/**
 * Returns the object with 4 properties. Each
 * of them means the correction to upper or lower
 * measure of the limit.
 * @return {object} object with minX, maxX, minY and maxY properties.
 */
Zapatec.Movable._getMovableShape = function() {
	//getting measurement element
	var measurement = this.getMovableMeasurement();
	//default corrections are equal 0
	var obj = {minX : 0, maxX : 0, minY : 0, maxY : 0};
	//currently we only support true value
	switch (this.getMoveConfig().followShape) {
		case (true) : {
			//not an HTML element no corrections
			if (!Zapatec.isHtmlElement(measurement)) {
				return obj;
			}
			//correcting upper bounds
			obj.maxX = -Zapatec.Utils.getWidth(measurement);
			obj.maxY = -Zapatec.Utils.getHeight(measurement);
			return obj
		}
		default : {
			return obj;
		}
	}
};

/**
 * Returns the coordinate of the moving point.
 * Its the point which is thought to be the 
 * center of movement.
 * @return {object} object with x and y properties.
 */
Zapatec.Movable.getMovingPoint = function() {
	return this.getScreenPosition();
};

/**
 * Iterates through all the elements in the
 * array and tryes to set their coordinates.
 * @param x {number} x coordinate.
 * @param y {number} y coordinate.
 * @param elements {array} array of elements to proceed.
 */
Zapatec.Movable._proceedElementsCoords = function(x, y, elements) {
	//making sure this is Zapatec.Array
	elements = Zapatec.Array(elements);
	//calculateing measurement position
	var measurement = this.getMovableMeasurement();
	var pos = null;
	if (Zapatec.isHtmlElement(measurement)) {
		pos = Zapatec.Utils.getPos(measurement);
	} else if (measurement && typeof measurement == "object") {
		pos = {
			x : (typeof measurement.x == "number") ? measurement.x : null, 
			y : (typeof measurement.y == "number") ? measurement.y : null
		};
		if (!measurement.x || !measurement.y) {
			pos = null;
		}
	}
	//iterating through all items
	elements.each(function(index, movable) {
		var mX = x, mY = y;
		//if there is measurement calculating position
		if (pos) {
			var mPos = null;
			if (Zapatec.isHtmlElement(movable)) {
				mPos = Zapatec.Utils.getPos(movable);
			} else if (Zapatec.isMovableObj(movable)) {
				mPos = movable.getPosition();
			} else {
				return;
			}
			if (x || x === 0) {
				mX = mPos.x + (x - pos.x);
			}
			if (y || y === 0) {
				mY = mPos.y + (y - pos.y);
			}
		}
		//setting position
		if (Zapatec.isHtmlElement(movable)) {
			Zapatec.Utils.moveTo(movable, mX, mY);
		} else if (Zapatec.isMovableObj(movable)) {
			movable.setPosition(mX, mY);
		}
	});
};

/**
 * Sorts elements in array by their path in the DOM
 * tree. This is usefull when you have synchronized 
 * elements that influence each other in the DOM tree
 * when you try to make them movable. The sort order
 * is descending.
 * @param elements {array} array of elements to be sorted.
 * @return {boolean} true if successful, otherwise false.
 */
Zapatec.Movable.sortElementsByPath = function(elements) {
	//making array of elements Zapatec.Array
	elements = Zapatec.Array(elements);
	//iterating through each item to get path and compare with others
	elements.each(function(index, element) {
		//no path - no action for this element
		var path = Zapatec.Utils.getElementPath(element, document.body);
		if (!path) {
			return;
		}
		//splitting path into array
		path = Zapatec.Array(path.split("-"));
		//compareing path with path of all other elements
		for(var i = index; i < elements.length; ++i) {
			//no path - no action for this element
			var compPath = Zapatec.Utils.getElementPath(elements[i], document.body);
			if (!compPath) {
				continue;
			}
			//splitting path into array
			compPath = Zapatec.Array(compPath.split("-"));
			//compareing parts of both pahs
			path.each(function(k, pathPiece, whole) {
				//if our part is bigger than breaking the cycle
				if (parseInt(pathPiece, 10) > (parseInt(compPath[k], 10) || 0)) {
					return "break";
				} else if (parseInt(pathPiece, 10) < parseInt(compPath[k], 10)) {
					//if our part is smaller then exchanging elements with
					//their places in array and breaking the cycle
					var el = elements[index]
					elements[index] = elements[i];
					elements[i] = el;
					path = compPath;
					return "break";
				}
				//continuing compareing if parts are equal
			});
		}
	});
	return true;
};

/**
 * This is Zapatec.Utils.Movable object definition.
 * This is done in the "interface" manner.
 * It represents most of the routines and
 * events connected to moving of the object.
 * @param config {object} - all parameters are passed as the properties of this object.
 * 
 * Constructor recognizes the following properties of the config object
 * \code
 *    prop. name     | description
 *  -------------------------------------------------------------------------------------------------
 *  container        | {HTML element} The main element to be movable (default null).
 *  synchronize      | {array} Elements to be synchronize in moving (default []).
 *  direction        | {string} Enabled direction of moving. Can be "vertical", "horizontal" or "both"
 *                   | (default "both").
 *  limit            | {object} Object with properties "minX", "maxX", "minY" and "maxY",
 *                   | that are used as restrictions for setting position.
 *  moveLayer        | {HTML element} Element to be used as movement parent (default document.body).
 *
 * \endcode
 */
Zapatec.Utils.Movable = function(config) {
	Zapatec.Utils.Movable.SUPERconstructor.call(this, config);
};

Zapatec.Utils.Movable.id = "Zapatec.Utils.Movable";
Zapatec.inherit(Zapatec.Utils.Movable, Zapatec.Widget);
//implementing Zapatec.CommandEvent interface
Zapatec.implement(Zapatec.Utils.Movable, "Zapatec.CommandEvent");
//implementing Zapatec.Movable interface
Zapatec.implement(Zapatec.Utils.Movable, "Zapatec.Movable");

/**
 * Inits the object with set of config options.
 * @param config {object} configuration parameters.
 */
Zapatec.Utils.Movable.prototype.init = function(config) {
	//calling parent init
	Zapatec.Utils.Movable.SUPERclass.init.call(this, config);
	var self = this;
	var elements = null;
	//makes object movable (means all elements that are movable)
	if (this.getConfiguration().makeMovable) {
		this.makeMovable();
	} else {
		elements = Zapatec.Array(this.getMovableElements());
		elements.each(function(index, movable) {
			if (Zapatec.isHtmlElement(movable)) {
				self.createProperty(movable, "moveObj", self);
			}
		});
	}
};

/**
 * Sets the default configuration of the object and
 * inits it with user defined values.
 * @param config {object} configuration parameters.
 */
Zapatec.Utils.Movable.prototype.configure = function(config) {
	//set of elements to be moved with container
	this.defineConfigOption("synchronize", []);
	//container, which is actually moved too and also 
	//is used as a measurement
	this.defineConfigOption("container", null);
	//limitations of the moving
	this.defineConfigOption("limit", {
		minX : null, 
		maxX : null, 
		minY : null, 
		maxY : null
	});
	//direction of move (you can enable move only in one direction)
	this.defineConfigOption("direction", "both");
	//moving layer, the element to be used as offset parent
	this.defineConfigOption("moveLayer", document.body);
	//restriction shape for the element
	this.defineConfigOption("followShape", "LT");
	//should we preserve element's sizes
	this.defineConfigOption("preserveSizes", true);
	//if false, init doesn't make element movable
	this.defineConfigOption("makeMovable", true);
	//no theme
	this.defineConfigOption("theme", null);
	// Call parent method
	Zapatec.Utils.Movable.SUPERclass.configure.call(this, config);
	config = this.getConfiguration();
	//checking if limit object wasn't overwritten
	if (!config.limit || typeof config.limit != "object") {
		config.limit = {
			minX : null, 
			maxX : null, 
			minY : null, 
			maxY : null
		};
	}
	var self = this;
	//making sure that config.syncronize will be Array.
	config.synchronize = Zapatec.Array(config.synchronize);
	config.synchronize.each(function(index, element) {
		if (element === null) {
			return;
		}
		element = Zapatec.Widget.getElementById(element);
		element = Zapatec.Utils.img2div(element);
		if (!element) {
			Zapatec.Log({description : "Wrong element in synchronize array for the movable object with ID '" + self.id + "'!"});
		} else {
			config.synchronize[index] = element;
		}
	});
	//setting default container element
	config.container = Zapatec.Widget.getElementById(config.container);
	config.container = Zapatec.Utils.img2div(config.container);
	if (!Zapatec.isHtmlElement(config.container)) {
		Zapatec.Log({description : "Wrong element passed as container for the movable object with ID '" + self.id + "'!"});	
	}
	this.movableElements = Zapatec.Array(config.synchronize.concat(config.container));
	if (this.movableElements.length > 1) {
		this.sortElementsByPath(this.movableElements);
	}
	//setting default move layer
	if (!Zapatec.isHtmlElement(config.moveLayer = Zapatec.Widget.getElementById(config.moveLayer))) {
		config.moveLayer = document.body;
	}
};

/**
 * Reconfigures the object with new parameters.
 * @param config {object} new configuration parameters.
 */
Zapatec.Utils.Movable.prototype.reconfigure = function(config) {
	// Call parent method
	Zapatec.Utils.Movable.SUPERclass.reconfigure.call(this, config);
};

/**
 * Returns the array of synchronized moving elements.
 * @return {array} array of elements that are synchronized
 */
Zapatec.Utils.Movable.prototype.getMovableElements = function() {
	return this.movableElements;
};
//$Id: draggable.js 6839 2007-04-03 08:51:13Z slip $
/**
 * This is a set of functionality used for dragging object
 * and is implemented in interface (mixin) manner.
 */
Zapatec.Draggable = {};

/**
 * Makes the element draggable. This means attaching events, 
 * and making some preparations.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Draggable.makeDraggable = function() {
	if (!this.hasInterface("Zapatec.Movable")) {
		Zapatec.Log({description : "The object with ID '" + this.id + "' has no Zapatec.Movable interface so can not be draggable!"});
		return false;
	}
	if (!this.hasInterface("Zapatec.CommandEvent")) {
		Zapatec.Log({description : "The object with ID '" + this.id + "' has no Zapatec.CommandEvent interface!"});
		return false;
	}
	var draggables = Zapatec.Array(this.getDraggableElements());
	var hooks = Zapatec.Array(this._getDraggableHooks());
	var self = this, result = false;
	var config = this.getDragConfig();
	//if method is not "cut" we can not imitate event capture
	if (config.method != "cut") {
		this.setDragConfig({eventCapture : false});
	}
	//we need to save references to anonymous event listenrs
	var listenersObj = this._getRestorer().getSavedProps()["dragListeners"] = {
		mousedown : function(ev) {
			return self.dragStart(ev);
		},
		mousemove : function(ev) {
			if (self.isDragging()) {
				return self.dragMove(ev);
			}
		},
		mouseup : function(ev) {
			if (self.isDragging()) {
				return self.dragEnd(ev);
			}
		}
	};
	hooks.each(function(index, hook) {
		if (!Zapatec.isHtmlElement(hook)) {
			return;
		}
		//if we are here than there is at least one hook :)
		result = true;
		//this for disabling text selection on drag
		if (Zapatec.is_gecko) {
			hook.style.setProperty("-moz-user-select", "none", "");
		}
		//adding drag start event
		Zapatec.Utils.addEvent(hook, 'mousedown', listenersObj.mousedown);
		//imitating capturing of some events. This is used when mouse event
		//is involved with hook element, cause there won't be a click event for
		//that element if cover will appear over it.
		if (config.eventCapture) {
			Zapatec.Utils.addEvent(hook, 'mousemove', listenersObj.mousemove);
			Zapatec.Utils.addEvent(hook, 'mouseup', listenersObj.mouseup);
		}
	});
	draggables.each(function(index, draggable) {
		if (!Zapatec.isHtmlElement(draggable)) {
			return;
		}
		//this is for backward compability and to be able to
		//get draggable object with only a reference to HTML element
		self.createProperty(draggable, "dragObj", self);
	});
	//returning result
	return result;	
};

/**
 * This is an event handler for the mouse down event 
 * of the hook element.
 * @param ev {MouseEvent} this is mouse event triggered by
 * mouse down action.
 * @return {false} false for stoping events in some browsers.
 */
Zapatec.Draggable.dragStart = function(ev) {
	if (!this.canDrag()) {
		return true;
	}
	//getting event object
	ev = ev || window.event;
	//check mouse button, only left one is valid
	var iButton = ev.button || ev.which;
	if (iButton > 1) {
		return false;
	}
	var self = this;
	var config = this.getDragConfig();
	//calling the handler
	if (this.fireEvent("beforeDragInit", ev) === false) {
		return true;
	}
	//calling global event handler
	if (Zapatec.GlobalEvents.fireEvent("beforeDragInit", ev, this) === false) {
		return true;
	}
	//now we started dragging!
	this._setDragging(true);
	//workaround for dummy and copy methods to capture events correctly
	if (config.eventCapture && (config.method == "dummy" || config.method == "copy")) {
		var draggables = Zapatec.Array(this.getDraggableElements());
		draggables.each(function(index, draggable) {
			draggable.restorer.saveProp("style.zIndex");
			draggable.style.zIndex = 2000001;
		});
	}
	//preparing elements
	this._proceedDraggableElements("dragStart");
	//lets get the starting position of the mouse
	var mouseX = ev.clientX + (Zapatec.is_khtml ? 0 : (Zapatec.Utils.getPageScrollX() || 0));
	var mouseY = ev.clientY + (Zapatec.is_khtml ? 0 : (Zapatec.Utils.getPageScrollY() || 0));
	//making object movable
	this.makeMovable();
	//starting movement
	this.startMove();
	//preparing movable elements
	var elements = Zapatec.Array(this.getMovableElements());
	elements.each(function(index, movable) {
		if (Zapatec.isHtmlElement(movable)) {
			//giving z-index
			movable.restorer.saveProp("style.zIndex");
			movable.style.zIndex = 1000000 + (parseInt(movable.style.zIndex, 10) || 0);
			//applying styles
			self._proceedDragStyles(movable, "dragStart");
			//assigning proper cursor if event capture
			if (config.eventCapture) {
				movable.restorer.saveProp("style.cursor");
				movable.style.cursor = "move";
			}
		} else if (Zapatec.isMovableObj(movable)) {
			//making recursive iterating through all child movables
			var elems = Zapatec.Array(movable.getMovableElements());
			elems.each(arguments.calee);
		}
	});
	Zapatec.Utils.cover.show(
		config.eventCapture ? 999999 : 2000000,
		"move",
		function(ev) {
			return self.dragMove(ev);
		},
		function(ev) {
			return self.dragEnd(ev);
		}
	);
	this._setMovingPoint(mouseX, mouseY);
	//calling the handler
	this.fireEvent("onDragInit", ev);

	//calling the global handler
	Zapatec.GlobalEvents.fireEvent("onDragInit", ev, this);
	
	if (config.stopEvent) {
		return Zapatec.Utils.stopEvent(ev);
	} else {
		return true;
	}
};

/**
 * This is an event handler for the mouse move event 
 * of the cover element.
 * @param ev {MouseEvent} this is mouse event triggered by
 * mouse move action.
 * @return {false} false for stoping events in some browsers.
 */
Zapatec.Draggable.dragMove = function(ev){
	if (!this.isDragging()) {
		return true;
	}
	//getting event object
	ev = ev || window.event;
	//calling the handler
	if (this.fireEvent("beforeDragMove", ev) === false) {
		return true;
	}
	//calling global event handler
	if (Zapatec.GlobalEvents.fireEvent("beforeDragMove", ev, this) === false) {
		return true;
	}
	if (Zapatec.Utils.cover.style.zIndex != 2000000) {
		var config = this.getDragConfig();
		//workaround for dummy and copy methods to handle eventCapture corectly
		if (config.eventCapture && (config.method == "dummy" || config.method == "copy")) {
			var draggables = Zapatec.Array(this.getDraggableElements());
			draggables.each(function(index, draggable) {
				draggable.restorer.restoreProp("style.zIndex");
			});
		}
		//putting cover over everything
		Zapatec.Utils.cover.style.zIndex = 2000000;
	}
	//mouse position
	var mouseX = ev.clientX + (Zapatec.is_khtml ? 0 : (Zapatec.Utils.getPageScrollX() || 0));
	var mouseY = ev.clientY + (Zapatec.is_khtml ? 0 : (Zapatec.Utils.getPageScrollY() || 0));
	var movePoint = this.getMovingPoint();
	this.moveFor(mouseX - movePoint.x, mouseY - movePoint.y);
	this._setMovingPoint(mouseX, mouseY);
	//calling the handler
	this.fireEvent("onDragMove", ev);

	//calling global event handler
	Zapatec.GlobalEvents.fireEvent("onDragMove", ev, this);

	// Stop event
	return Zapatec.Utils.stopEvent(ev);
};

/**
 * This is an event handler for the mouse up event 
 * of the cover element.
 * @param ev {MouseEvent} this is mouse event triggered by
 * mouse up action.
 * @return {false} false for stoping events in some browsers.
 */
Zapatec.Draggable.dragEnd = function(ev){
	if (!this.isDragging()) {
		return true;
	}
	//getting event object
	ev = ev || window.event;
	var self = this;
	//calling the handler
	if (this.fireEvent("beforeDragEnd", ev) === false) {
		return true;
	}
	//calling global event handler
	if (Zapatec.GlobalEvents.fireEvent("beforeDragEnd", ev, this) === false) {
		return true;
	}
	var config = this.getDragConfig();
	//workaround for dummy and copy methods to handle eventCapture corectly
	if (config.eventCapture && (config.method == "dummy" || config.method == "copy")) {
		var draggables = Zapatec.Array(this.getDraggableElements());
		draggables.each(function(index, draggable) {
			draggable.restorer.restoreProp("style.zIndex", true);
		});
	}
	//restoring movable elements
	var elements = Zapatec.Array(this.getMovableElements());
	elements.each(function(index, movable) {
		if (Zapatec.isHtmlElement(movable)) {
			movable.restorer.restoreProp("style.zIndex");
			movable.restorer.restoreProp("style.cursor");
			//clearing styles
			self._proceedDragStyles(movable, "dragEnd");
		} else if (Zapatec.isMovableObj(movable)) {
			//making recursive iterating through all child movables
			var elems = Zapatec.Array(movable.getMovableElements());
			elems.each(arguments.calee);
		}
	});

	//unprepareing elements
	this._proceedDraggableElements("dragEnd");
	//hiding the cover
	Zapatec.Utils.cover.hide();
	//clearing moving point
	this._setMovingPoint(null, null);
	//now we ended dragging!
	this._setDragging(false);
	//ending movement
	this.endMove();
	//calling the handler
	this.fireEvent("onDragEnd", ev);

	//calling global event handler
	Zapatec.GlobalEvents.fireEvent("onDragEnd", ev, this);

	// Stop event
	return Zapatec.Utils.stopEvent(ev);
};

/** 
 * returns element to its original place where it was taken from.
 * Applicable only for the cut method!
 */
Zapatec.Draggable.restorePos = function(){
	this.restoreOfMove();
};

/**
 * Restores object from dragging.
 */
Zapatec.Draggable.restoreOfDrag = function() {
	this.restoreOfMove();
	var hooks = Zapatec.Array(this._getDraggableHooks());
	var draggables = Zapatec.Array(this.getDraggableElements());
	var self = this;
	var config = this.getDragConfig();
	//we need to save references to anonymous event listenrs
	var listenersObj = this._getRestorer().getSavedProps()["dragListeners"];
	hooks.each(function(index, hook) {
		if (!Zapatec.isHtmlElement(hook)) {
			return;
		}
		if (Zapatec.is_gecko) {
			hook.style.setProperty("-moz-user-select", "", "");
		}
		Zapatec.Utils.removeEvent(hook, 'mousedown', listenersObj.mousedown);
		if (config.eventCapture) {
			Zapatec.Utils.removeEvent(hook, 'mousemove', listenersObj.mousemove);
			Zapatec.Utils.removeEvent(hook, 'mouseup', listenersObj.mouseup);
		}
	});
	draggables.each(function(index, draggable) {
		if (!Zapatec.isHtmlElement(draggable)) {
			return;
		}
		draggable.dragObj = null;
	});
	return true;
};

/**
 * This method should return the array of elements that
 * are to be draggable. These are not always elements
 * that are actually moved. This is almost empty method
 * that should be overwritten in implementing class.
 * @return {array} array of draggable elements.
 */
Zapatec.Draggable.getDraggableElements = function() {
	return this.getContainer();
};

/**
 * This method should return the array of elements that
 * are handles for dragging. These are elements that 
 * trigger drag start. This is almost empty method
 * that should be overwritten in implementing class.
 * @return {array} array of hook elements.
 */
Zapatec.Draggable._getDraggableHooks = function() {
	return this.getContainer();
};

/**
 * Returns container for this object.
 */
Zapatec.Draggable.getContainer = function() {
	return this.getDragConfig().container;
};

/**
 * This method returns true if object started
 * dragging, otherwise false.
 * @return {boolean} true if object is dragging,
 * otherwise false.
 */
Zapatec.Draggable.isDragging = function() {
	return this.dragging;
};

/**
 * This method returns true if dragging is enabled,
 * otherwise it should return false.
 * @return {boolean} true if dragging enabled, otherwise false.
 */
Zapatec.Draggable.canDrag = function() {
	return this.canDrag;
};

/**
 * Turns on or off dragging.
 * @param on {boolean} whether we want to 
 * turn on or off dragging.
 */
Zapatec.Draggable._setCanDrag = function(on) {
	this.canDrag = on;
};

/**
 * Should returns the dragging configuration.
 * @return {object} configuration object.
 */
Zapatec.Draggable.getDragConfig = function() {
	return this.getConfiguration();
};

/**
 * Sets the dragging configuration.
 * @param config {object} a set of new configuration.
 */
Zapatec.Draggable.setDragConfig = function(config) {
	this.reconfigure(config);
};

/**
 * Sets the flag of dragging to on or off.
 * @param on {boolean} true to turn on, otherwise false.
 */
Zapatec.Draggable._setDragging = function(on) {
	this.dragging = on;
};

/**
 * This method handles overflow of the dragging coordinate.
 * @param limit {number} limit that was overflowed.
 * @param dimension {string} dimension of coordinate.
 * @return {number or boolean} new coordinate or false.
 */
Zapatec.Draggable._handleCoordOverflow = function(limit, dimension) {
	if (!this.isDragging()) {
		Zapatec.Movable._handleCoordOverflow.call(this, limit, dimension);
	}
	return limit;
};

/**
 * Returns the Zapatec.SRProp object.
 * It is used for saving and restoring
 * object properties.
 * @return {object} Zapatec.SRProp object.
 */
Zapatec.Draggable._getRestorer = function() {
	if (!this.restorer) {
		this.restorer = new Zapatec.SRProp(this);
	}
	return this.restorer;
};

/**
 * Proceeds the array of draggable elements, to create
 * a separate array for elements that are actually moving.
 * This is used to handle method of dragging.
 * @param dragState {string} "dragStart" or "dragEnd" string 
 * to point the state of dragging.
 */
Zapatec.Draggable._proceedDraggableElements = function(dragState) {
	//drag configuration
	var config = this.getDragConfig(), 
	restorer = this._getRestorer(),
	copies = null, measurement = null, self = this,
	listenersObj = restorer.getProp("dragListeners");
	function toggleEvents(action, hooks, listenersObj) {
		hooks.each(function(index, hook) {
			Zapatec.Utils[action + "Event"](hook, "mousedown", listenersObj.mousedown);
			if (config.eventCapture) {
				Zapatec.Utils[action + "Event"](hook, 'mousemove', listenersObj.mousemove);
				Zapatec.Utils[action + "Event"](hook, 'mouseup', listenersObj.mouseup);
			}
		});
	}
	switch (config.method) {
		case "copy" : case "dummy" : {
			if (dragState == "dragStart") {
				var elements = Zapatec.Array(this.getDraggableElements());
				var hooks = Zapatec.Array(this._getDraggableHooks());
				copies = Zapatec.Array();
				//removing listeners so the elements will be cloned
				//without them.
				toggleEvents("remove", hooks, listenersObj);
				//copying elements
				elements.each(function(index, movable) {
					if (Zapatec.isHtmlElement(movable)) {
						//cloning a node
						var newNode = movable.cloneNode(config.copyChilds);
						newNode.dragObj = null;
						newNode.within = null;
						//adding event listeners
						if (config.eventCapture) {
							Zapatec.Utils.addEvent(newNode, 'mousemove', listenersObj.mousemove);
							Zapatec.Utils.addEvent(newNode, 'mouseup', listenersObj.mouseup);
						}
						//inserting it to the place where the original one is
						movable.parentNode.insertBefore(newNode, movable);
						//fix for unknown problem in IE6
						newNode.style.visibility = "visible";
						//adding copy to array
						copies.push(newNode);
						//assigning new measurement
						if (movable == self.getMovableMeasurement()) {
							measurement = newNode;
						}
					} else if (Zapatec.isMovableObj(movable)) {
						//making recursive iterating through all child movables
						var elems = Zapatec.Array(movable.getMovableElements());
						elems.each(arguments.calee);
					}
				});
				//adding listeners back
				toggleEvents("add", hooks, listenersObj);
				//if there was no measurement copied we take the
				//original one
				if (!measurement) {
					measurement = this.getMovableMeasurement();
				}
				//we substitute methods of Zapatec.Movable
				//interface to get needed result
				restorer.saveProp("getMovableElements");
				restorer.saveProp("isMovableSafely()");
				//new elements need to be movable safely
				this._setMovableSafely(false);
				//we need to move copies
				this.getMovableElements = function(resetArray) {
					var arr = copies;
					copies = resetArray ? null : copies;
					return arr;
				};
				restorer.saveProp("getMovableMeasurement");
				//we need to use copied measurement if such exists
				this.getMovableMeasurement = function() {
					return measurement;
				};
			} else if (dragState == "dragEnd") {
				//destroying elements if needed
				var elements = Zapatec.Array(this.getMovableElements(true));
				elements.each(function(index, movable) {
					if (config.method == "dummy") {
						movable.parentNode.removeChild(movable);
					}
					//removing event listeners
					if (config.eventCapture) {
						Zapatec.Utils.removeEvent(movable, 'mousemove', listenersObj.mousemove);
						Zapatec.Utils.removeEvent(movable, 'mouseup', listenersObj.mouseup);
					}
				});
				this.restoreOfMove();
				//returning old methods and values
				restorer.restoreProp("getMovableElements");
				this._setMovableSafely(restorer.getProp("isMovableSafely()"));
				restorer.restoreProp("isMovableSafely()");
				restorer.restoreProp("getMovableMeasurement");
			}
			break;
		}
		default : {
			break;
		}
	}
};

/**
 * Proceeds each movable element with some
 * styling routines on drag start and end.
 * @param movable {HTML element} element to proceed.
 * @param dragState {string} string pointing to drag state.
 */
Zapatec.Draggable._proceedDragStyles = function(movable, dragState) {
	var config = this.getDragConfig();
	//overwriting class with new one if needed
	if (config.overwriteCSS) {
		if (dragState == "dragStart") {
			movable.restorer.saveProp("className");
			movable.className = config.overwriteCSS;
		} else if (dragState == "dragEnd") {
			movable.restorer.restoreProp("className");
		}
	}
	//adding drag class if needed
	if (config.dragCSS) {
		if (dragState == "dragStart") {
			Zapatec.Utils.addClass(movable, config.dragCSS);
		} else if (dragState == "dragEnd") {
			Zapatec.Utils.removeClass(movable, config.dragCSS);
		}
	}
};

/**
 * Sets the coordinates of the point which is thought as
 * the center of movement of the object.
 * @param x {number} x coordinate of the point.
 * @param y {number} y coordinate of the point.
 */
Zapatec.Draggable._setMovingPoint = function(x, y) {
	var movingPoint = this._getMovingPointObject();
	//this means drag end, so we should reset the object
	if (x === null || y === null) {
		movingPoint.x = null;
		movingPoint.y = null;
		movingPoint.offsetX = null;
		movingPoint.offsetY = null;
		return;
	}
	//this means drag start, so we fill object
	if (movingPoint.x === null || movingPoint.y === null) {
		var pos = this.getPagePosition();
		movingPoint.x = x;
		movingPoint.y = y;
		movingPoint.offsetX = x - pos.x;
		movingPoint.offsetY = y - pos.y;
	} else {//changing point coordinates as this is drag move
		var pos = this.getPagePosition();
		movingPoint.x = pos.x + movingPoint.offsetX;
		movingPoint.y = pos.y + movingPoint.offsetY;
	}
	return;
};

/**
 * Returns the coordinate of the moving point.
 * Its the point which is thought to be the 
 * center of movement.
 * @return {object} object with x and y properties.
 */
Zapatec.Draggable.getMovingPoint = function() {
	var movingPoint = this._getMovingPointObject();
	return {x : movingPoint.x, y : movingPoint.y};
};

/**
 * Returns the object which holds the information about moving point.
 * @return {object} object with x, y, offsetX and offsetY properties.
 */
Zapatec.Draggable._getMovingPointObject = function() {
	if (!this.movingPoint || typeof this.movingPoint != "object") {
		this.movingPoint = {x : null, y : null, offsetX : null, offsetY : null};
	}
	return this.movingPoint;
};

/**
 * This is Zapatec.Utils.Draggable object definition.
 * It represents most of the routines and
 * events connected to dragging of the object.
 * @param config {object} - all parameters are passed as the properties of this object.
 * 
 * Constructor recognizes the following properties of the config object (rest options are inherited
 * from Zapatec.Utils.Movable object, see movable.js comments)
 * \code
 *    prop. name     | description
 *  -------------------------------------------------------------------------------------------------
 *  method           | {string} Method of dragging, can be "cut", "copy" or "dummy" (default "cut").
 *  stopEvent        | {boolean} Should we stop mousedown event of the handler (default true). 
 *  eventCapture     | {boolean} This is a workaround for capturing some events like click or double
 *                   | click for the element that triggers dragging. Otherwise there will happen no
 *                   | such event at all (default false).
 *  handler          | {HTML element} Handle of dragging, otherwise container will be used (default null).
 *  dragCSS          | {string} Class name that will be added to the element while it is dragging (default "").
 *  overwriteCSS     | {string} Class name that will overwrite all the classes of the element (default "").
 *
 * \endcode
 * There have been made some changes into the structure of DnD routines, so many options were changed.
 * They are still working for keeping backward compability, but are depricated for the future use.
 * Here is the list of the options and their equivalents:
 * \code
 *    prop. name     | description
 *  -------------------------------------------------------------------------------------------------
 *  left, top, right,| Use "limit" option of the Zapatec.Utils.Movable object!
 *  bottom           |
 *  dragLayer        | Use "moveLayer" option of the Zapatec.Utils.Movable object!
 *  beforeDragInit,  | Use standart Zapatec.Widget option "listeners"
 *  beforeDragMove,  |
 *  beforeDragEnd,   |
 *  onDragInit,      |
 *  onDragMove,      |
 *  onDragEnd        |
 *  stopEv           | Use "stopEvent" form instead.
 *
 * \endcode
 */
Zapatec.Utils.Draggable = function(config) {
	if (arguments.length > 1) {
		var args = arguments[1];
		args.container = config;
		config = args;
	}
	//for backward compability
	if (typeof config.left != "undefined" || typeof config.right != "undefined" ||
	    typeof config.top != "undefined" || typeof config.bottom != "undefined") {
			config.limit = {
				minX : config.left, 
				maxX : config.right, 
				minY : config.top, 
				maxY : config.bottom
			};
	}
	if (config.dragLayer) {config.moveLayer = config.dragLayer;}
	if (!config.eventListeners) {
		config.eventListeners = {};
	}
	if (config.beforeDragInit) {config.eventListeners.beforeDragInit = config.beforeDragInit;}
	if (config.beforeDragMove) {config.eventListeners.beforeDragMove = config.beforeDragMove;}
	if (config.beforeDragEnd) {config.eventListeners.beforeDragEnd = config.beforeDragEnd;}
	if (config.onDragInit) {config.eventListeners.onDragInit = config.onDragInit;}
	if (config.onDragMove) {config.eventListeners.onDragMove = config.onDragMove;}
	if (config.onDragEnd) {config.eventListeners.onDragEnd = config.onDragEnd;}
	if (config.stopEv) {config.stopEvent = config.stopEv;}
	config = Zapatec.Hash.remove(config, 
		"left", "top", "right", "bottom", "dragLayer",
		"beforeDragInit", "beforeDragMove", "beforeDragEnd",
		"onDragInit", "onDragMove", "onDragEnd", "stopEv"
	);
	Zapatec.Utils.Draggable.SUPERconstructor.call(this, config);
};

Zapatec.Utils.Draggable.id = "Zapatec.Utils.Draggable";
Zapatec.inherit(Zapatec.Utils.Draggable, Zapatec.Utils.Movable);
Zapatec.implement(Zapatec.Utils.Draggable, "Zapatec.Draggable");

/**
 * Inits the object with set of config options.
 * @param config {object} configuration parameters.
 */
Zapatec.Utils.Draggable.prototype.init = function(config) {
	//calling parent init
	Zapatec.Utils.Draggable.SUPERclass.init.call(this, config);
	//making draggable
	this.makeDraggable();
};

/**
 * Sets the default configuration of the object and
 * inits it with user defined values.
 * @param config {object} configuration parameters.
 */
Zapatec.Utils.Draggable.prototype.configure = function(config) {
	//method of dragging
	this.defineConfigOption("method", "cut");
	//should we stop mouse down event!
	this.defineConfigOption("stopEvent", true);
	//should we capture mouse down event!
	this.defineConfigOption("eventCapture", false);
	//the handler for dragging
	this.defineConfigOption("handler", null);
	//dragging class name, will be added to all present classes
	this.defineConfigOption("dragCSS", null);
	//dragging overwrite class name, will overwrite all present 
	//classes, but they will be restored on drag end
	this.defineConfigOption("overwriteCSS", null);
	//this option is only useful for dummy or copy methods
	//and determines whether we copy child content of the elements
	this.defineConfigOption("copyChilds", true);
	//redefining the makeMovable option to cancel the action
	//defined in Zapatec.Movable class
	this.defineConfigOption("makeMovable", false);
	// Call parent method
	Zapatec.Utils.Draggable.SUPERclass.configure.call(this, config);
	config = this.getConfiguration();
	//Opera has strange behaviour - when you just click element starts draging,
	//although mouseup should have been called.
	if (Zapatec.is_opera) {
		config.eventCapture = true;
	}
	//correcting handler option
	config.handler = Zapatec.Widget.getElementById(config.handler);
	config.handler = Zapatec.Utils.img2div(config.handler);
	if (!Zapatec.isHtmlElement(config.handler)) {
		config.handler = config.container;
	}
};

/**
 * Reconfigures the object with new parameters.
 * @param config {object} new configuration parameters.
 */
Zapatec.Utils.Draggable.prototype.reconfigure = function(config) {
	// Call parent method
	Zapatec.Utils.Draggable.SUPERclass.reconfigure.call(this, config);
};

/**
 * Returns the array of all draggable elements.
 * @return {array} array of draggable elements.
 */
Zapatec.Utils.Draggable.prototype.getDraggableElements = function() {
	return this.movableElements;
};

/**
 * Returns the handler.
 * @return {HTML element} handler element.
 */
Zapatec.Utils.Draggable.prototype._getDraggableHooks = function() {
	return this.getConfiguration().handler;
};

/**
 * searches elements with className=class and makes them draggable(useful to call it on document load)
 * @param class {string} searcable element's CSSclassname.
 * @param el {HTMLElement} reference to the element.
 * @param recursive {boolean} searches in childs.
 * @param config {object} config object for draggable.
 * @return {array} array of draggable objects
 */
Zapatec.Utils.initDragObjects = function(className, el, recursive, config){
	//only by class name :)
	if (!className) return;
	//array of elements to make draggable
	var elements = Zapatec.Utils.getElementsByAttribute('className', className, el, recursive, true);
	//returning result
	return Zapatec.Utils.applyToElements(Zapatec.Utils.Draggable, elements, config);
}
//$Id: sizable.js 6834 2007-04-02 06:49:19Z slip $
/**
 * This is a set of functionality used for sizing object
 * and is implemented in interface (mixin) manner.
 */
Zapatec.Sizable = {};

/**
 * Sets the width of the object. Basically the width parameter
 * is connected to the measurement element and its resulting width
 * will be equal to this value, but it doesn't mean that the
 * method will directly set the width of it, it can work with
 * it's childs actually.
 * @param width {number} width to set.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Sizable.setWidth = function(width) {
	return this._setDimension(width, "width");
};

/**
 * Sets the height of the object. Basically the height parameter
 * is connected to the measurement element and its resulting height
 * will be equal to this value, but it doesn't mean that the
 * method will directly set the height of it, it can work with
 * it's childs actually.
 * @param height {number} height to set.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Sizable.setHeight = function(height) {
	return this._setDimension(height, "height");
};

/**
 * This method is used for the objects that use
 * such concept as orientation. Method reacts on
 * two types of orientation: "vertical" and "horizontal".
 * @param width {number} oriented width to set.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Sizable.setOrientedWidth = function(width) {
	//getOrientation should return the orientation of the
	//object. You can extend two types overwriting
	//handleOrientedWidth method.
	if (!this.getOrientation) {
		return false;
	}
	switch (this.getOrientation()) {
		case "vertical" : 
			//vertical orientation means height
			return this._setDimension(width, "height");
		case "horizontal" : 
			//horizontal orientation means width
			return this._setDimension(width, "width");
	}
};

/**
 * This method is used for the objects that use
 * such concept as orientation. Method reacts on
 * two types of orientation: "vertical" and "horizontal".
 * @param height {number} oriented height to set.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Sizable.setOrientedHeight = function(height) {
	//getOrientation should return the orientation of the
	//object. You can extend two types overwriting
	//handleOrientedHeight method.
	if (!this.getOrientation) {
		return false;
	}
	switch (this.getOrientation()) {
		case "vertical" :
			//vertical orientation means width
			return this._setDimension(height, "width");
		case "horizontal" :
			//horizontal orientation means height
			return this._setDimension(height, "height");
	}
};

/**
 * Sets the size of the passed dimension.
 * @param val {number or string} value to set.
 * @param dimension {string} "width" or "height".
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Sizable._setDimension = function(val, dimension) {
	//same string just with first character uper case, it is used for event names
	var evDim = dimension.charAt(0).toUpperCase() + dimension.slice(1);
	//preparations which can depend on the Widget.
	if (!this.isSizableSafely(dimension)) {
		Zapatec.Log({description : "The object " + dimension + " ID '" + this.id + "' was not prepared for sizing! Use obj.makeSizable() to do so!", type : "warning"});
		return false;
	}
	//_parseSize takes the width value and first of all
	//tryes to return the numeric representation in pixels.
	//Also if it returns null value (false, "", 0 are also
	//treated so) method stops execution without making something.
	//This can be useful for implementing restrictions.
	var msgValue = val + "";
	val = this._parseSize(val, dimension);
	if (!val) {
		Zapatec.Log({description : "The " + dimension + " " + msgValue + " can not be set for object with ID '" + this.id + "'!", type : "warning"});
		return false;
	}
	//getSizableElements returns the array of elements
	//that actually are sized. Param passed is the dimension 
	//we size.
	var elements = Zapatec.Array(this.getSizableElements(dimension));
	//this array is used for saving previous widths and associated sizable objects,
	//this way we can restore all widths, if sizing fails on some stage
	var toRestore = [], self = this;
	//firing event
	if (this.fireEvent("before" + evDim + "Change", val) === false) {
		return false;
	}
	if (Zapatec.GlobalEvents.fireEvent("before" + evDim + "Change", val, this) === false) {
		return false;
	}
	//checking if we didn't fail during the loop,
	if (!this._proceedElementsSizes(val, dimension, elements, toRestore)) {
		//if failure we need to return back all heights
		this._rollBackSizing(toRestore, dimension);
		this.fireEvent(dimension + "ChangeFailure", val)
		Zapatec.GlobalEvents.fireEvent(dimension + "ChangeFailure", val, this)
		Zapatec.Log({description : "Impossible to set the " + dimension + " " + msgValue + " for the object with ID '" + this.id + "'!", type : "warning"});
		return false;
	} else {
		if (this.isSizing()) {
			if (dimension == "width") {
				this.fireEvent("onSizing", val, this.getHeight());
				Zapatec.GlobalEvents.fireEvent("onSizing", val, this.getHeight(), this);
			} else {
				this.fireEvent("onSizing", this.getWidth(), val);
				Zapatec.GlobalEvents.fireEvent("onSizing", this.getWidth(), val, this);
			}
		}
		this.fireEvent("on" + evDim + "Change", val);
		Zapatec.GlobalEvents.fireEvent("on" + evDim + "Change", val, this);
	}
	//reporting success.
	return true;
};

/**
 * Strats the event of sizing. This is used
 * to send message to interested objects that
 * sizing was started. This involves the calling
 * of "onSizing" event from setWidth and setHeight.
 * endSizing method stops the action.
 * @return {boolean} true if success, otherwise false
 */
Zapatec.Sizable.startSizing = function() {
	//preparations which can depend on the Widget.
	if (!this.isSizableSafely()) {
		Zapatec.Log({description : "The object with ID '" + this.id + "' was not prepared for sizing! Use obj.makeSizable() to do so!", type : "warning"});
		return false;
	}
	this.fireEvent("sizingStart");
	Zapatec.GlobalEvents.fireEvent("sizingStart", this);
	this._setSizingState(true);
	return true;
};

/**
 * Ends the event of sizing. This is used
 * to send message to interested objects that
 * sizing was ended. This stops the calling
 * of "onSizing" event from setWidth and setHeight.
 * @return {boolean} true if success, otherwise false
 */
Zapatec.Sizable.endSizing = function() {
	if (!this.isSizing()) {
		Zapatec.Log({description : "The sizing for object with ID '" + this.id + "' was not started!", type : "warning"});
		return false;
	}
	this.fireEvent("sizingEnd");
	Zapatec.GlobalEvents.fireEvent("sizingEnd", this);
	this._setSizingState(false);
	return true;
};

/**
 * Gets the state of sizing. It returns
 * true if sizing was started, otherwise
 * it returns false.
 * @return {boolean} true if sizing started, otherwise false
 */
Zapatec.Sizable.isSizing = function() {
	return this.sizingState;
};

/**
 * Sets the state of sizing to true or false.
 * This is used internally and can be overwritten
 * in child classes to use another propety for the flag.
 */
Zapatec.Sizable._setSizingState = function(on) {
	this.sizingState = on;
};

/**
 * Returns the width of the measurement element.
 * If there is no such, then the biggest width
 * of sizable elements will be taken.
 * @return {number or boolean} the width or false iif failure.
 */
Zapatec.Sizable.getWidth = function() {
	//trying to get measurement of sizing
	var el = this.getSizableMeasurement("width");
	//if we success then return its width or its value
	if (Zapatec.isHtmlElement(el) || typeof el == "number") {
		return Zapatec.Utils.getWidth(el) || el;
	}
	//otherwise reporting failure
	Zapatec.Log({description : "Can't calculate width for object with ID '" + this.id + "'!", type : "warning"});
	return false;
};

/**
 * Returns the height of the measurement element.
 * If there is no such, then the biggest height
 * of sizable elements will be taken.
 * @return {number or boolean} the height or false iif failure.
 */
Zapatec.Sizable.getHeight = function() {
	//trying to get measurement of sizing
	var el = this.getSizableMeasurement("height");
	//if we success then return its height or its value
	if (Zapatec.isHtmlElement(el) || typeof el == "number") {
		return Zapatec.Utils.getHeight(el) || el;
	}
	//otherwise reporting failure
	Zapatec.Log({description : "Can't calculate height for object with ID '" + this.id + "'!", type : "warning"});
	return false;
};

/**
 * Is object prepared for sizing.
 * Mostly you will need to redefine this method,
 * to use some other property as a flag.
 * @return {boolean} true if prepared, otherwise false.
 */
Zapatec.Sizable.isSizableSafely = function(dimension) {
	return this.safelySizable;
};

/**
 * Makes all sizable elements safely sizable.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Sizable.makeSizable = function() {
	if (!this.hasInterface("Zapatec.CommandEvent")) {
		Zapatec.Log({description : "The object with ID '" + this.id + "' has no Zapatec.CommandEvent interface!"});
		return false;
	}
	if (this.isSizableSafely()) {
		return true;
	}
	//getting array of elements which should be sizable
	//without parameters this function should always
	//return all possible sizable elements
	var elements = Zapatec.Array(this.getSizableElements()), 
	success = true, self = this;
	//trying to prepare each element
	elements.each(function(index, sizable) {
		sizable = Zapatec.Array(sizable);
		sizable.each(function(index, sizable) {
			if (Zapatec.isHtmlElement(sizable)) {
				//prepareing HTML elements
				if (!Zapatec.Utils.makeSafelySizable(sizable)) {
					success = false;
					return "break";
				}
				self.createProperty(sizable, "sizingObj", self);
			} else if (Zapatec.isSizableObj(sizable)) {
				//prepareing sizable objects
				if (!sizable.makeSizable()) {
					success = false;
					return "break";
				}
			}
		});
	});
	//if there was failure we need roll back all the preparations
	if (!success) {
		//restoreing elements or objects
		this.restoreOfSizing();
		//reporting error
		Zapatec.Log({description : "Can not make the object with ID '" + this.id + "' sizable!"});
		return false;
	}
	//reporting success
	this._setSizableSafely(true);
	return true;
};

/**
 * Restoreing object of sizable state.
 * @return {boolean} always returns true.
 */
Zapatec.Sizable.restoreOfSizing = function() {
	if (!this.isSizableSafely()) {
		return true;
	}
	//getting all sizable elements
	var elements = Zapatec.Array(this.getSizableElements());
	//restoreing each item
	elements.each(function(index, sizable) {
		sizable = Zapatec.Array(sizable);
		sizable.each(function(index, sizable) {
			if (Zapatec.isHtmlElement(sizable)) {
				Zapatec.Utils.restoreOfSizing(sizable);
				sizable.sizingObj = null;
			} else if (Zapatec.isSizableObj(sizable)) {
				sizable.restoreOfSizing();
			}
		});
	});
	//returning success
	this._setSizableSafely(false);
	return true;
};

/**
 * Replaces the element with the given
 * one. The given one will be made
 * sizable.
 * @param element {HTML element} element to replace.
 * @param withEl {HTML element} replacement element.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Sizable.replaceWithSizable = function(element, withEl) {
	if (!Zapatec.isHtmlElement(element) || !Zapatec.isHtmlElement(withEl)) {
		return false;
	}
	var width = Zapatec.Utils.getWidth(element);
	var height = Zapatec.Utils.getHeight(element);
	element.parentNode.insertBefore(withEl, element.nextSibling);
	element.parentNode.removeChild(element);
	if (!Zapatec.Utils.makeSafelySizable(withEl)) {
		return false;
	}
	if (Zapatec.Utils.setWidth(withEl, width) && Zapatec.Utils.setHeight(withEl, height)) {
		return true;
	}
	return false;
};

/**
 * Fills some flag with the true or false value.
 * Same flag should be used in isSafelySizable method.
 * @param on {boolean} turn on or turn of.
 */
Zapatec.Sizable._setSizableSafely = function(on) {
	this.safelySizable = on;
};

/**
 * Parses the value of the size argument
 * to calculate the number in pixels.
 * if this method returns null or false
 * or "" or 0 nothing is done at all.
 * Currently recognizes "auto", px and % size.
 * @param width {string} string representation of the size.
 * @param dimension {string} dimension in which we should parse.
 * @return {number or null} null if nothing should be done 
 * by setWidth or setHeight method, otherwise returns the size in pixels.
 */
Zapatec.Sizable._parseSize = function(size, dimension) {
	switch (true) {
		case (size == "auto") : {
			size = this._parseAutoSize(dimension);
			break;
		}
		case ((/^\d+px$/).test(String(size))) : {
			size = parseInt(size, 10);
			break;
		}
		case ((/^\d+%$/).test(String(size))) : {
			size = this._parsePercentSize(size, dimension);
			break;
		}
		case (typeof size == "number") : {
			break;
		}
	}
	return this._canSetSize(size, dimension);
};

/**
 * Returns the value to be used as size in pixels for 
 * the measure element used for auto sizing the element
 * returned by _getAutoSizableElement.
 * @param dimension {string} dimension to parse for value.
 * @return {number or null} needed width or null if can not
 * do this.
 */
Zapatec.Sizable._parseAutoSize = function(dimension) {
	//getting measurement and autosizable element. Auto sizable means
	//we'll try to size element to fit this elements content.
	var measurement = this.getSizableMeasurement(dimension);
	var autoSizable = this._getAutoSizableElement(dimension);
	if (!Zapatec.isHtmlElement(autoSizable)) {
		return null;
	}
	var dim = dimension.charAt(0).toUpperCase() + dimension.slice(1).toLowerCase();
	//calculateing difference between this element and measurement (if there is one)
	var diff = 0;
	if (Zapatec.isHtmlElement(measurement) || typeof measurement == "number") {
		diff = (Zapatec.Utils["get" + dim](measurement) || measurement) - Zapatec.Utils["get" + dim](autoSizable);
	}
	//workaround for iframe
	var el = autoSizable;
	if (el.tagName.toLowerCase() == "iframe") {
		try {
			if (el.contentDocument != null) {
				el = el.contentDocument.body;
			} else if (el.contentWindow.document != null) {
				el = el.contentWindow.document.body;
			}
			if (!Zapatec.isHtmlElement(el)) {
				throw "No element to calculate auto size!";
			}
		} catch(e) {
			Zapatec.Log({description : "Can't calculate auto size for the IFRAME in the object with ID '" + this.id + "'!", type : "warning"});
			return null;
		}
	}
	//returning new size.
	return el["scroll" + dim] + diff;
};

/**
 * Returns the value to be used as size in pixels for 
 * the measure element used for sizing it in percents
 * to _getSizableParent.
 * @param value {string} value to parse.
 * @param dimension {string} dimension to parse in.
 * @return {number or null} needed width or null if can not
 * do this.
 */
Zapatec.Sizable._parsePercentSize = function(value, dimension) {
	//getting the parent element to calculate percents of its size.
	var sizableParent = this._getSizableParent(dimension);
	if (!Zapatec.isHtmlElement(sizableParent)) {
		return null;
	}
	var dim = dimension.charAt(0).toUpperCase() + dimension.slice(1).toLowerCase();
	value = parseInt(value, 10);
	//calculating percents
	return Math.round((value / 100) * Zapatec.Utils["get" + dim](sizableParent));
};

/**
 * Returns value if this value for this dimension can be set.
 * This is currently default method, but you can overwrite it 
 * for implementing your way of restriction.
 * @param value {string} value to check.
 * @param dimension {string} dimension to check.
 * @return {number or boolean} coordinate if the size can be set, 
 * otherwise false.
 */
Zapatec.Sizable._canSetSize = function(value, dimension) {
	if (typeof value != "number") {
		return false;
	}
	var dim = dimension.charAt(0).toUpperCase() + dimension.slice(1).toLowerCase();
	var sizingConfig = this.getSizingConfig();
	var limit = sizingConfig.limit;
	var direction = sizingConfig.direction;
	if (dim == "Width" && direction == "vertical") {
		return this._handleSizeOverflow(this.getWidth());
	}
	if (dim == "Height" && direction == "horizontal") {
		return this._handleSizeOverflow(this.getHeight());
	}
	if (typeof limit["min" + dim] == "number" && value < limit["min" + dim]) {
		return this._handleSizeOverflow(limit["min" + dim]);
	}
	if (typeof limit["max" + dim] == "number" && value > limit["max" + dim]) {
		return this._handleSizeOverflow(limit["max" + dim]);
	}
	return value;
};

/**
 * A method to handle size overflow of the limit.
 * @param limit {number} limit that was overflowed.
 * @param dimension {string} dimension of sizing.
 * @return {boolean or number} false if can not set,
 * otherwise new coordinate.
 */
Zapatec.Sizable._handleSizeOverflow = function(limit, dimension) {
	return false;
};

/**
 * Returns the configuration of sizable object.
 * @return {object} object with configuration.
 */
Zapatec.Sizable.getSizingConfig = function() {
	return this.getConfiguration();
};

/**
 * Sets the sizing configuration.
 * @param config {object} a set of new configuration.
 */
Zapatec.Sizable.setSizingConfig = function(config) {
	this.reconfigure(config);
};

/**
 * Gets the element to be used for getting size which fits
 * its content without overflow. It will mostly always 
 * be overwritten by your function.
 * @param dimension {string} dimension we are working with.
 * @return {HTML element} should always be HTML element.
 */
Zapatec.Sizable._getAutoSizableElement = function(dimension) {
	return this.getContainer();
};

/**
 * Gets the element to be used for getting size in percents
 * of its size. It will mostly always be overwritten by your function.
 * @param dimension {string} dimension we are working with.
 * @return {HTML element} should always be HTML element.
 */
Zapatec.Sizable._getSizableParent = function(dimension) {
	return this.getContainer().parentNode;
};

/**
 * Returns the measurement element for this sizable
 * object. This a generous method, and mostly will
 * be overwritten in implementing class.
 * @param dimension {string} string pointing to dimension that is
 * setting or calculating. You can use this to make difference
 * between dimensions.
 * @return {null or number or HTML element} method should return
 * null if there is no measure, or number or HTML element to 
 * calculate measurement.
 */
Zapatec.Sizable.getSizableMeasurement = function(dimension) {
	return this.getContainer();
};

/**
 * Returns the array of elements to be sized in this
 * object. This a generous method, and mostly will
 * be overwritten in implementing class.
 * @param dimension {string} string pointing to dimension that is
 * setting or calculating. You can use this to make difference
 * between dimensions.
 * @return {mixed} method should return null if there is no sizable 
 * elements, or array of HTML elements or Zapatec.Sizable objects
 * to size them or get their size or prepare them.
 */
Zapatec.Sizable.getSizableElements = function(dimension) {
	return this.getContainer();
};

/**
 * Returns the container element.
 * @return {HTML element} container element.
 */
Zapatec.Sizable.getContainer = function() {
	return this.getSizingConfig().container;
};

/**
 * Sets the size of the particular element.
 * @param size {number} the size to set.
 * @param sizable {mixed} element or object to be sized.
 * @param dimension {string} dimension to set.
 * @return {object or boolean} object with two properties: "sizable" - sizable object,
 * "oldSize" - its old size for restoring on failure; or it returns false if failure
 * or true if this was not sizable element.
 */
Zapatec.Sizable._setElementSize = function(size, sizable, dimension) {
	var dim = dimension.charAt(0).toUpperCase() + dimension.slice(1).toLowerCase();
	//we take each element
	if (Zapatec.isHtmlElement(sizable)) {
		//trying to set the height of the element
		if (Zapatec.Utils["set" + dim](sizable, size)) {
			return true;
		} else {
			return false;
		}
	} else if (Zapatec.isSizableObj(sizable)) {
		//trying to set the height of the Zapatec.Sizable object
		if (sizable["set" + dim](size)) {
			return true;
		} else {
			return false;
		}
	}

	return true;
};

/**
 * Proceeds the matrix (2dim array) of elements to size them accordingly.
 * @param value {number} value of the size to be proceed.
 * @param dimension {string} dimension to be proceed.
 * @param elArr {array} array of elements to be proceed.
 * @param restArr {array} array of elements to be restored if failure 
 * (it is filled during the method work).
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Sizable._proceedElementsSizes = function(value, dimension, elArr, restArr) {
	var diff = null, self = this, sizes = Zapatec.Array();
	//getSizableMeasurement is used to get the
	//measurement element or some number. This
	//variable is used as a measurement of current
	//size. Param passed is the dimension we size.
	var measurement = this.getSizableMeasurement(dimension);
	var dim = dimension.charAt(0).toUpperCase() + dimension.slice(1).toLowerCase();
	if (typeof measurement == "number" || Zapatec.isHtmlElement(measurement)) {
		//if there is measurement then height of our element is changed by the following
		//value - (height - measurement)
		diff = value - (Zapatec.Utils["get" + dim](measurement) || measurement);
	}
	//elements array should be 2 dimensional, at least it will be
	//emulated so. Second dimension holds the elements that share one difference.
	elArr = Zapatec.Array(elArr);
	//calculating the array of sizes to be set
	elArr.each(function(row, val) {
		var oneDiff = diff, size = value;
		val = Zapatec.Array(val);
		//if there is difference we share it between elements,
		//otherwise we share size!
		if (diff) {
			oneDiff = Math.round(oneDiff / val.length);
		} else {
			size = Math.round(size / val.length);
		}
		//adding new row to sizes array
		sizes[row] = [];
		//iterating through second dimension
		val.each(function(index, sizable) {
			var setSize = null;
			var elSize = null;
			//taking element size
			if (Zapatec.isHtmlElement(sizable)) {
				elSize = Zapatec.Utils["get" + dim](sizable)
			} else if (Zapatec.isSizableObj(sizable)) {
				elSize = sizable["get" + dim]();
			} else {
				return;
			}
			if (oneDiff || oneDiff === 0) {
				//can't make mistakes :)
				if (index != val.length - 1) {
					setSize = elSize + oneDiff;
				} else {
					setSize = elSize + (diff - oneDiff * index);
				}
			} else {
				//can't make mistakes :)
				if (index != val.length - 1) {
					setSize = size;
				} else {
					setSize = value - size * index;
				}
			}
			//saving size
			sizes[row][index] = {setSize : setSize, elSize : elSize};
		});
	});
	var res = elArr.each(function(row, val) {
		val = Zapatec.Array(val);
		//iterating through second dimension
		var res = val.each(function(index, sizable) {
			if (!sizes[row][index]) {
				return;
			}
			var res = self._setElementSize(sizes[row][index].setSize, sizable, dimension);
			if (!res && res === false) {
				return "break";
			} else {
				restArr.push({sizable : sizable, oldSize : sizes[row][index].elSize});
			}
		});
		if (!res && res === false) {
			return "break";
		}
	});
	return res;
};
 
/**
 * Rolls back the size of elements from the array.
 * @param rollBackArr {array} array of objects of the following structure:
 * {sizable : HTML element or Sizable object, oldSize : size to restore}.
 * @param dimension {string} dimension to roll back.
 */
Zapatec.Sizable._rollBackSizing = function(rollBackArr, dimension) {
	var dim = dimension.charAt(0).toUpperCase() + dimension.slice(1).toLowerCase();
	rollBackArr = Zapatec.Array(rollBackArr);
	rollBackArr.each(function(index, obj) {
		if (Zapatec.isHtmlElement(obj.sizable)) {
			Zapatec.Utils["set" + dim](obj.sizable, obj.oldSize);
		} else if (Zapatec.isSizableObj(obj.sizable)) {
			obj.sizable["set" + dim](obj.oldSize);
		}
	});
};

/**
 * This is Zapatec.Utils.Sizable object definition.
 * This is done in the "interface" manner.
 * It represents most of the routines and
 * events connected to sizing of the object.
 * @param config {object} - all parameters are passed as the properties of this object.
 * 
 * Constructor recognizes the following properties of the config object
 * \code
 *    prop. name     | description
 *  -------------------------------------------------------------------------------------------------
 *  container        | {HTML element} The main element to be sizable (default null).
 *  syncVertically   | {array} Elements to be synchronize in vertical sizing. The important thing 
 *                   | about this is that each element of this array can be array too and this means 
 *                   | that elements from that sub array will share the height change proportionally,
 *                   | otherwise, if there is only one element or it is not sub array but one element,
 *                   | it will tkae all the height change. To illustrate this: if you pass [el1, [el2, el3]]
 *                   | and your container has height 200px, after you cahnge the height to 300px
 *                   | el1 will change its height for 100px, but el2 and el3 will change their height
 *                   | for 50px both. (default []).
 *  syncHorizontally | {array} Elements to be synchronize in horizontal sizing. The important thing 
 *                   | about this is that each element of this array can be array too and this means 
 *                   | that elements from that sub array will share the width change proportionally,
 *                   | otherwise, if there is only one element or it is not sub array but one element,
 *                   | it will tkae all the width change. To illustrate this: if you pass [el1, [el2, el3]]
 *                   | and your container has width 200px, after you cahnge the width to 300px
 *                   | el1 will change its width for 100px, but el2 and el3 will change their width
 *                   | for 50px both. (default []).
 *  direction        | {string} Enabled direction of sizing. Can be "vertical", "horizontal" or "both"
 *                   | (default "both").
 *  limit            | {object} Object with properties "minWidth", "maxWidth", "minHeight" and "maxHeight",
 *                   | that are used as restrictions for setting size.
 * 
 * \endcode
 */
Zapatec.Utils.Sizable = function(config) {
	Zapatec.Utils.Sizable.SUPERconstructor.call(this, config);
};

Zapatec.Utils.Sizable.id = "Zapatec.Utils.Sizable";
Zapatec.inherit(Zapatec.Utils.Sizable, Zapatec.Widget);
//implementing Zapatec.CommandEvent interface
Zapatec.implement(Zapatec.Utils.Sizable, "Zapatec.CommandEvent");
//implementing Zapatec.Sizable interface
Zapatec.implement(Zapatec.Utils.Sizable, "Zapatec.Sizable");

/**
 * Inits the object with set of config options.
 * @param config {object} configuration parameters.
 */
Zapatec.Utils.Sizable.prototype.init = function(config) {
	//calling parent init
	Zapatec.Utils.Sizable.SUPERclass.init.call(this, config);
	//makes object sizable (means all elements that are sizable)
	this.makeSizable();
};

/**
 * Sets the default configuration of the object and
 * inits it with user defined values.
 * @param config {object} configuration parameters.
 */
Zapatec.Utils.Sizable.prototype.configure = function(config) {
	//set of elements to be sized with container vertically
	this.defineConfigOption("syncVertically", []);
	//set of elements to be sized with container horizontally
	this.defineConfigOption("syncHorizontally", []);
	//container, which is actually sized too and also 
	//is used as a measurement
	this.defineConfigOption("container", null);
	//direction of sizing (you can enable sizing only in one direction)
	this.defineConfigOption("direction", "both");
	//limitations of the sizing
	this.defineConfigOption("limit", {
		minWidth : 10, 
		maxWidth : null, 
		minHeight : 10, 
		maxHeight : null
	});
	//no theme
	this.defineConfigOption("theme", null);
	// Call parent method
	Zapatec.Utils.Sizable.SUPERclass.configure.call(this, config);
	config = this.getConfiguration();
	//checking if limit object wasn't overwritten
	if (!config.limit || typeof config.limit != "object") {
		config.limit = {
			minWidth : null, 
			maxWidth : null, 
			minHeight : null, 
			maxHeight : null
		};
	}
	var self = this;
	//making sure that config.syncVertically will be Array.
	config.syncVertically = Zapatec.Array(config.syncVertically);
	config.syncVertically.each(function(index, subArr) {
		config.syncVertically[index] = Zapatec.Array(subArr);
		config.syncVertically[index].each(function(elIndex, element) {
			if (element === null) {
				return;
			}
			element = Zapatec.Widget.getElementById(element);
			if (!element) {
				Zapatec.Log({description : "Wrong element in syncVertically array for the sizable object with ID '" + self.id + "'!"});
			} else {
				config.syncVertically[index][elIndex] = element;
			}
		});
	});
	//making sure that config.syncVertically will be Array.
	config.syncHorizontally = Zapatec.Array(config.syncHorizontally);
	config.syncHorizontally.each(function(index, subArr) {
		config.syncHorizontally[index] = Zapatec.Array(subArr);
		config.syncHorizontally[index].each(function(elIndex, element) {
			if (element === null) {
				return;
			}
			element = Zapatec.Widget.getElementById(element);
			if (!element) {
				Zapatec.Log({description : "Wrong element in syncHorizontally array for the sizable object with ID '" + self.id + "'!"});
			} else {
				config.syncHorizontally[index][elIndex] = element;
			}
		});
	});
	//setting default container element
	if (!Zapatec.isHtmlElement(config.container = Zapatec.Widget.getElementById(config.container))) {
		config.container = null;
	}
};

/**
 * Reconfigures the object with new parameters.
 * @param config {object} new configuration parameters.
 */
Zapatec.Utils.Sizable.prototype.reconfigure = function(config) {
	// Call parent method
	Zapatec.Utils.Sizable.SUPERclass.reconfigure.call(this, config);
};

/**
 * We overwrite the method of Zapatec.Sizable interface
 * to return the array of needed sizable elements.
 * @param {array} array of sizable elements.
 */
Zapatec.Utils.Sizable.prototype.getSizableElements = function(dimension) {
	var config = this.getConfiguration();
	if (dimension && dimension.toLowerCase() == "width") {
		return config.syncHorizontally.concat(config.container);
	} else if (dimension && dimension.toLowerCase() == "height") {
		return config.syncVertically.concat(config.container);
	} else {
		return config.syncVertically.concat(config.syncHorizontally).concat(config.container);
	}
};

//$Id: resizable.js 6679 2007-03-20 16:39:44Z slip $
/**
 * This is a set of functionality used for resizing object
 * and is implemented in interface (mixin) manner.
 */
Zapatec.Resizable = {};

/**
 * Makes the element resizable. This means attaching events, 
 * and making some preparations.
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Resizable.makeResizable = function() {
	if (!this.hasInterface("Zapatec.Sizable")) {
		Zapatec.Log({description : "The object with ID '" + this.id + "' has no Zapatec.Sizable interface so can not be resizable!"});
		return false;
	}
	if (!this.hasInterface("Zapatec.CommandEvent")) {
		Zapatec.Log({description : "The object with ID '" + this.id + "' has no Zapatec.CommandEvent interface!"});
		return false;
	}
	var hooks = Zapatec.Array(this._getResizableHooks());
	var measurement = this.getSizableMeasurement();
	var self = this, result = false;
	var config = this.getResizeConfig();
	//if direction includes top and left resizing we need Zapatec.Movable interface
	if (/(vertical|horizontal|top|left|all)/.test(config.direction) && !this.hasInterface("Zapatec.Movable")) {
		Zapatec.Log({description : "The object with ID '" + this.id + "' has no Zapatec.Movable interface so can not be resizable!"});
		return false;
	}
	//we need to save references to anonymous event listenrs
	var listenersObj = this._getRestorer().getSavedProps()["resizeListeners"] = {
		mousedown : function(ev) {
			return self.resizeStart(ev);
		},
		hover : function(ev) {
			if (!self.isResizing() && self.canResize()) {
				self._toggleResizeCursor(ev);
			}
		},
		mouseover : function(ev) {
			if (self.hasInterface("Zapatec.Draggable")) {
				self._setCanDrag(false);
			}
		},
		mouseout : function(ev) {
			if (self.hasInterface("Zapatec.Draggable")) {
				self._setCanDrag(true);
			}
		}
	};
	hooks.each(function(index, hook) {
		if (!Zapatec.isHtmlElement(hook)) {
			return;
		}
		//if we are here than there is at least one hook :)
		result = true;
		//this for disabling text selection on resize
		if (Zapatec.is_gecko) {
			hook.style.setProperty("-moz-user-select", "none", "");
		}
		//adding resize start event
		Zapatec.Utils.addEvent(hook, 'mousedown', listenersObj.mousedown);
		Zapatec.Utils.addEvent(hook, 'mouseover', listenersObj.mouseover);
		Zapatec.Utils.addEvent(hook, 'mouseout', listenersObj.mouseout);
	});
	//if there are no hooks, we use measurement border as trigger
	if (!result) {
		//if it is not an HTML element then we have no trigger
		if (!Zapatec.isHtmlElement(measurement)) {
			return false;
		}
		//result is true now
		result = true;
		//adding resize events
		Zapatec.Utils.addEvent(measurement, 'mousedown', listenersObj.mousedown);
		Zapatec.Utils.addEvent(measurement, 'mousemove', listenersObj.hover);
	}
	//returning result
	return result;	
};

/**
 * This method is used for determining cursor 
 * for current mouse position if the resizing 
 * trigger is elements border.
 * @param ev {object} event object.
 */
Zapatec.Resizable._toggleResizeCursor = function(ev) {
	ev = ev || window.event;
	var el = this.getSizableMeasurement();
	//lets get the position of the mouse
	var config = this.getResizeConfig();
	//mouse position
	var posX = ev.clientX + Zapatec.Utils.getPageScrollX() || 0;
	var posY = ev.clientY + Zapatec.Utils.getPageScrollY() || 0;
	//element boundaries
	var pos = Zapatec.Utils.getElementOffset(el);
	var left = pos.x, right = pos.x + Zapatec.Utils.getWidth(el);
	var top = pos.y, bottom = pos.y + Zapatec.Utils.getHeight(el);
	//resizing border thickness
	var borderThickness = config.borderThickness;
	var cornerThickness = config.cornerThickness;
	//checks if point is in rectangle
	function inRect(x, y, left, top, right, bottom) {
		if ((x > left) && (x < right) && (y > top) && (y < bottom)) {
			return true;
		}
		return false;
	}
	//checks if value is in range
	function inRange(value, minVal, maxVal) {
		if ((value > minVal) && (value < maxVal)) {
			return true;
		}
		return false;
	}
	//sets cursor and disables/enables dragging
	var self = this;
	function toggleResizing(cursor) {
		el.style.cursor = cursor;
		if (self.hasInterface("Zapatec.Draggable")) {
			self._setCanDrag((cursor === "") ? true : false);
		}
	}
	//getting the needed direction cursor and toggling drag
	switch (true) {
		case (inRect(posX, posY, left, top, left + borderThickness, top + borderThickness)) : {
			toggleResizing("nw-resize");
			break;
		}
		
		case (inRect(posX, posY, right - cornerThickness, bottom - cornerThickness, right, bottom)) : {
			toggleResizing("se-resize");
			break;
		}
	
		case (inRect(posX, posY, right - cornerThickness, top, right, top + borderThickness)) : {
			toggleResizing("ne-resize");
			break;
		}
		
		case (inRect(posX, posY, left, bottom - cornerThickness, left + cornerThickness, bottom)) : {
			toggleResizing("sw-resize");
			break;
		}
	
		case (inRange(posX, left, left + borderThickness)) : {
			toggleResizing("w-resize");
			break;
		}
		
		case (inRange(posX, right - borderThickness, right)) : {
			toggleResizing("e-resize");
			break;
		}
	
		case (inRange(posY, top, top + borderThickness)) : {
			toggleResizing("n-resize");
			break;
		}
		
		case (inRange(posY, bottom - borderThickness, bottom)) : {
			toggleResizing("s-resize");
			break;
		}
	
		default : {
			toggleResizing("");
			break;
		}
	}
	//correcting direction
	el.style.cursor = this._correctDirection(el.style.cursor);
	if (el.style.cursor == "") {
		if (this.hasInterface("Zapatec.Draggable")) {
			this._setCanDrag(true);
		}
	}
};

/**
 * Corrects the cursor value to fit the
 * direction config option.
 * @param direction {string} cursor value, 
 * meaning the direction of resizing.
 * @return {string} new cursor, meaning the
 * enabled direction.
 */
Zapatec.Resizable._correctDirection = function(direction) {
	//getting config
	var config = this.getResizeConfig();
	//taking direction part
	direction = direction.replace("-resize", "");
	//excluding impossible action
	for (var i = 0; i < direction.length; ++i) {
		switch(direction.charAt(i)) {
			case "n" : {
				if (!/(all|vertical|top)/.test(config.direction)) {
					direction = direction.replace("n", "");
				}
			}
			case "s" : {
				if (!/(all|vertical|bottom)/.test(config.direction)) {
					direction = direction.replace("s", "");
				}
			}
			case "w" : {
				if (!/(all|horizontal|left)/.test(config.direction)) {
					direction = direction.replace("w", "");
				}
			}
			case "e" : {
				if (!/(all|horizontal|right)/.test(config.direction)) {
					direction = direction.replace("e", "");
				}
			}
		}
	}
	//returning new cursor
	if (direction != "") {
		return direction + "-resize";
	}
	return "";
};
 
/**
 * This is an event handler for the mouse down event 
 * of the hook element.
 * @param ev {MouseEvent} this is mouse event triggered by
 * mouse down action.
 * @return {false} false for stoping events in some browsers.
 */
Zapatec.Resizable.resizeStart = function(ev, deb) {
	if (!this.canResize()) {
		return true;
	}
	//getting event object
	ev = ev || window.event;
	//check mouse button, only left one is valid
	var iButton = ev.button || ev.which;
	if (iButton > 1) {
		return true;
	}
	var self = this;
	var config = this.getResizeConfig();
	//getting the direction of resizement
	var target = ev.currentTarget || ev.srcElement;
	while(target != document.body && target.style.cursor.indexOf("resize") == -1) {
		target = target.parentNode;
	}
	//it is pointed in the cursor style property of trigger element
	if (target.style.cursor.indexOf("resize") == -1) {
		return true;
	}
	//correction direction
	var direction = this._correctDirection(target.style.cursor);
	if (direction == "") {
		return true;
	}
	//calling the handler
	if (this.fireEvent("beforeResizeInit", ev) === false) {
		return true;
	}
	//calling global event handler
	if (Zapatec.GlobalEvents.fireEvent("beforeResizeInit", ev, this) === false) {
		return true;
	}
	//now we started resizing!
	this._setResizing(true);
	//preparing elements
	this._proceedResizableElements("resizeStart");
	//lets get the starting position of the mouse
	var mouseX = ev.clientX + Zapatec.Utils.getPageScrollX() || 0;
	var mouseY = ev.clientY + Zapatec.Utils.getPageScrollY() || 0;
	//making object sizable
	this.makeSizable();
	//starting sizing
	this.startSizing();
	if (/(vertical|horizontal|top|left|all)/.test(config.direction)) {
		//making object movable
		this.makeMovable();
		//starting movement
		this.startMove();
	}
	
	Zapatec.Utils.cover.show(
		1000001,
		direction,
		function(ev) {
			return self.resizeMove(ev);
		},
		function(ev) {
			return self.resizeEnd(ev);
		}
	);
	this._setResizingPoint(mouseX, mouseY, direction.replace("-resize", ""));
	//calling the handler
	this.fireEvent("onResizeInit", ev);

	//calling the global handler
	Zapatec.GlobalEvents.fireEvent("onResizeInit", ev, this);
	
	if (config.stopEvent) {
		return Zapatec.Utils.stopEvent(ev);
	} else {
		return true;
	}
};

/**
 * This is an event handler for the mouse move event 
 * of the cover element.
 * @param ev {MouseEvent} this is mouse event triggered by
 * mouse move action.
 * @return {false} false for stoping events in some browsers.
 */
Zapatec.Resizable.resizeMove = function(ev){
	if (!this.isResizing()) {
		return true;
	}
	//getting event object
	ev = ev || window.event;
	//calling the handler
	if (this.fireEvent("beforeResize", ev) === false) {
		return true;
	}
	//calling global event handler
	if (Zapatec.GlobalEvents.fireEvent("beforeResize", ev, this) === false) {
		return true;
	}
	//mouse position
	var x = ev.clientX + Zapatec.Utils.getPageScrollX() || 0;
	var y = ev.clientY + Zapatec.Utils.getPageScrollY() || 0;
	var movePoint = this.getResizingPoint();
	var direction = Zapatec.Utils.cover.style.cursor;
	direction = direction.replace("-resize", "");
	if (direction.indexOf("w") > -1) {
		var width = this.getWidth();
		this.setWidth(width + (movePoint.x - x));
		if (width != this.getWidth()) {
			this.moveFor(width - this.getWidth(), null);
		}
	}
	if (direction.indexOf("e") > -1) {
		this.setWidth(this.getWidth() + (x - movePoint.x));
	}
	if (direction.indexOf("n") > -1) {
		var height = this.getHeight();
		this.setHeight(height + (movePoint.y - y));
		if (height != this.getHeight()) {
			this.moveFor(null, height - this.getHeight());
		}
	}
	if (direction.indexOf("s") > -1) {
		this.setHeight(this.getHeight() + (y - movePoint.y));
	}
	this._setResizingPoint(x, y, direction);
	//calling the handler
	this.fireEvent("onResize", ev);

	//calling global event handler
	Zapatec.GlobalEvents.fireEvent("onResize", ev, this);

	// Stop event
	return Zapatec.Utils.stopEvent(ev);
};

/**
 * This is an event handler for the mouse up event 
 * of the cover element.
 * @param ev {MouseEvent} this is mouse event triggered by
 * mouse up action.
 * @return {false} false for stoping events in some browsers.
 */
Zapatec.Resizable.resizeEnd = function(ev){
	if (!this.isResizing()) {
		return true;
	}
	//getting event object
	ev = ev || window.event;
	var self = this;
	var config = this.getResizeConfig();
	//calling the handler
	if (this.fireEvent("beforeResizeEnd", ev) === false) {
		return true;
	}
	//calling global event handler
	if (Zapatec.GlobalEvents.fireEvent("beforeResizeEnd", ev, this) === false) {
		return true;
	}
	//unprepareing elements
	this._proceedResizableElements("resizeEnd");
	//hiding the cover
	Zapatec.Utils.cover.hide();
	//clearing moving point
	this._setResizingPoint(null, null);
	//now we ended dragging!
	this._setResizing(false);
	//ending sizing
	this.endSizing();
	if (/(vertical|horizontal|top|left|all)/.test(config.direction)) {
		//ending movement
		this.endMove();
	}
	//calling the handler
	this.fireEvent("onResizeEnd", ev);

	//calling global event handler
	Zapatec.GlobalEvents.fireEvent("onResizeEnd", ev, this);

	// Stop event
	return Zapatec.Utils.stopEvent(ev);
};

/**
 * Restores object from resizing.
 */
Zapatec.Resizable.restoreOfResize = function() {
	var config = this.getResizeConfig();
	this.restoreOfSizing();
	if (/(vertical|horizontal|top|left|all)/.test(config.direction)) {
		this.restoreOfMove();
	}
	var hooks = Zapatec.Array(this._getResizableHooks());
	var self = this;
	var result = false;
	//we need to save references to anonymous event listenrs
	var listenersObj = this._getRestorer().getSavedProps()["resizeListeners"];
	hooks.each(function(index, hook) {
		if (!Zapatec.isHtmlElement(hook)) {
			return;
		}
		result = true;
		if (Zapatec.is_gecko) {
			hook.style.setProperty("-moz-user-select", "", "");
		}
		Zapatec.Utils.removeEvent(hook, 'mousedown', listenersObj.mousedown);
		Zapatec.Utils.removeEvent(hook, 'mouseover', listenersObj.mouseover);
		Zapatec.Utils.removeEvent(hook, 'mouseout', listenersObj.mouseout);
	});
	if (!result) {
		var measurement = this.getSizableMeasurement();
		if (!Zapatec.isHtmlElement(measurement)) {
			return false
		}
		Zapatec.Utils.removeEvent(measurement, 'mousedown', listenersObj.mousedown);
		Zapatec.Utils.removeEvent(measurement, 'mousemove', listenersObj.hover);
	}
	return true;
};

/**
 * This method should return the array of elements that
 * are handles for resizing. These are elements that 
 * trigger resize start. This is almost empty method
 * that should be overwritten in implementing class.
 * @return {array} array of hook elements.
 */
Zapatec.Resizable._getResizableHooks = function() {
	if (this.getContainer) {
		return this.getContainer();
	} else {
		return null;
	}
};

/**
 * This method returns true if object started
 * resizing, otherwise false.
 * @return {boolean} true if object is resizing,
 * otherwise false.
 */
Zapatec.Resizable.isResizing = function() {
	return this.resizing;
};

/**
 * This method returns true if resizing is enabled,
 * otherwise it should return false.
 * @return {boolean} true if resizing enabled, otherwise false.
 */
Zapatec.Resizable.canResize = function() {
	return this.canResize;
};

/**
 * Turns on or off resizing.
 * @param on {boolean} whether we want to 
 * turn on or off resizing.
 */
Zapatec.Resizable._setCanResize = function(on) {
	this.canResize = on;
};

/**
 * Should returns the resizing configuration.
 * @return {object} configuration object.
 */
Zapatec.Resizable.getResizeConfig = function() {
	return this.getConfiguration();
};

/**
 * Sets the resizing configuration.
 * @param config {object} a set of new configuration.
 */
Zapatec.Resizable.setResizeConfig = function(config) {
	this.reconfigure(config);
};

/**
 * Sets the flag of resizing to on or off.
 * @param on {boolean} true to turn on, otherwise false.
 */
Zapatec.Resizable._setResizing = function(on) {
	this.resizing = on;
};

/**
 * This method handles overflow of the size.
 * @param limit {number} limit that was overflowed.
 * @param dimension {string} dimension of size.
 * @return {number or boolean} new size or false.
 */
Zapatec.Resizable._handleSizeOverflow = function(limit, dimension) {
	if (!this.isResizing()) {
		Zapatec.Sizable._handleSizeOverflow.call(this, limit, dimension);
	}
	return limit;
};

/**
 * Returns the Zapatec.SRProp object.
 * It is used for saving and restoring
 * object properties.
 * @return {object} Zapatec.SRProp object.
 */
Zapatec.Resizable._getRestorer = function() {
	if (!this.restorer || this.restorer.constructor != Zapatec.SRProp) {
		 this.restorer = new Zapatec.SRProp(this);
	}
	return this.restorer;
};

/**
 * Proceeds the resizable elements, to create
 * a separate array for elements that are actually sizing.
 * This is used to handle method of resizing.
 * @param resizeState {string} "resizeStart" or "resizeEnd" string 
 * to point the state of resizing.
 */
Zapatec.Resizable._proceedResizableElements = function(resizeState) {
	//drag configuration
	var config = this.getResizeConfig(), 
	copy = null, measurement = null, self = this;
	switch (config.method) {
		case "copy" : {
			if (resizeState == "resizeStart") {
				var measurement = this.getSizableMeasurement();
				if (!Zapatec.isHtmlElement(measurement)) {
					return false;
				}
				copy = measurement.cloneNode(false);
				measurement.parentNode.insertBefore(copy, measurement);
				//we substitute method of Zapatec.Sizable
				//interface to get needed result
				this._getRestorer().saveProp("getSizableElements");
				//we need to move copy
				this.getSizableElements = function() {
					return copy;
				};
				this._getRestorer().saveProp("getSizableMeasurement");
				//we need to use copy as measurement
				this.getSizableMeasurement = function() {
					return copy;
				};
				if (/(vertical|horizontal|top|left|all)/.test(config.direction)) {
					//we substitute method of Zapatec.Movable
					//interface to get needed result
					this._getRestorer().saveProp("getMovableElements");
					//we need to move copy
					this.getMovableElements = function(resetArray) {
						return copy;
					};
					this._getRestorer().saveProp("getMovableMeasurement");
					//we need to use copy as measurement
					this.getMovableMeasurement = function() {
						return copy;
					};
				}
			} else if (resizeState == "resizeEnd") {
				//destroying elements if needed
				copy = this.getMovableElements();
				var width = this.getWidth();
				var height = this.getHeight();
				var pos = null;
				if (/(vertical|horizontal|top|left|all)/.test(config.direction)) {
					pos = this.getPosition();
				}
				copy.parentNode.removeChild(copy);
				//returning old methods
				this._getRestorer().restoreProp("getSizableElements");
				this._getRestorer().restoreProp("getSizableMeasurement");
				this._getRestorer().restoreProp("getMovableElements");
				this._getRestorer().restoreProp("getMovableMeasurement");
				this.setWidth(width);
				this.setHeight(height);
				if (pos) {
					this.setPosition(pos.x, pos.y);
				}
			}
			break;
		}
		default : {
			break;
		}
	}
};

/**
 * Sets the coordinates of the point which is thought as
 * the center of resizement of the object.
 * @param x {number} x coordinate of the point.
 * @param y {number} y coordinate of the point.
 * @param direction {string} direction of resizing.
 */
Zapatec.Resizable._setResizingPoint = function(x, y, direction) {
	var resizingPoint = this._getResizingPointObject();
	//this means resize end, so we should reset the object
	if (x === null || y === null) {
		resizingPoint.x = null;
		resizingPoint.y = null;
		resizingPoint.offsetX = null;
		resizingPoint.offsetY = null;
		return;
	}
	//this means resize start, so we fill object
	if (resizingPoint.x === null || resizingPoint.y === null) {
		resizingPoint.x = x;
		resizingPoint.y = y;
		var width = this.getWidth();
		var height = this.getHeight();
		if (direction.match(/(n|w)/)) {
			var pos = this.getScreenPosition();
		}
		if (direction.indexOf("n") != -1) {
			resizingPoint.offsetY = y - pos.y;
		}
		if (direction.indexOf("w") != -1) {
			resizingPoint.offsetX = x - pos.x;
		}
		if (direction.indexOf("e") != -1) {
			resizingPoint.offsetX = x - width;
		}
		if (direction.indexOf("s") != -1) {
			resizingPoint.offsetY = y - height;
		}
		resizingPoint.offsetX = resizingPoint.offsetX || 0;
		resizingPoint.offsetY = resizingPoint.offsetY || 0;
	} else {//changing point coordinates as this is drag move
		var diffX = 0;
		var diffY = 0;
		var width = this.getWidth();
		var height = this.getHeight();
		if (direction.match(/(n|w)/)) {
			var pos = this.getScreenPosition();
		}
		if (direction.indexOf("n") != -1) {
			diffY = pos.y;
		}
		if (direction.indexOf("w") != -1) {
			diffX = pos.x;
		}
		if (direction.indexOf("e") != -1) {
			diffX = width;
		}
		if (direction.indexOf("s") != -1) {
			diffY = height;
		}
		resizingPoint.x = diffX + resizingPoint.offsetX;
		resizingPoint.y = diffY + resizingPoint.offsetY;
	}
	return;
};

/**
 * Returns the coordinate of the resizing point.
 * Its the point which is thought to be the 
 * center of resizement.
 * @return {object} object with x and y properties.
 */
Zapatec.Resizable.getResizingPoint = function() {
	var resizingPoint = this._getResizingPointObject();
	return {x : resizingPoint.x, y : resizingPoint.y};
};

/**
 * Returns the object which holds the information about resizing point.
 * @return {object} object with x, y, offsetX and offsetY properties.
 */
Zapatec.Resizable._getResizingPointObject = function() {
	if (!this.resizingPoint || typeof this.resizingPoint != "object") {
		this.resizingPoint = {x : null, y : null, offsetX : null, offsetY : null};
	}
	return this.resizingPoint;
};

/**
 * This is Zapatec.Utils.Resizable object definition.
 * It represents most of the routines and
 * events connected to resizing of the object.
 * @param config {object} - all parameters are passed as the properties of this object.
 * 
 * Constructor recognizes the following properties of the config object (rest options are inherited
 * from Zapatec.Utils.Sizable object, see sizable.js comments)
 * \code
 *    prop. name     | description
 *  -------------------------------------------------------------------------------------------------
 *  method           | {string} Method of resizing, can be "self" or "copy" (default "self").
 *  stopEvent        | {boolean} Should we stop mousedown event of the handler (default true). 
 *  handlers         | {array} Array of handles of resizing, otherwise container border will be 
 *                   | used as a trigger (default null).
 *  direction        | {string} Direction in which you can resize. Can be "all", "vertical", 
 *                   | "horizontal", "top", "left", "right", "bottom" and their combinations
 *                   | using "-" separator (default "all").
 *  borderThickness  | {number} If there is no handler for resizing, this is the thickness of 
 *                   | the container border which still triggers resizing.
 *  cornerThickness  | {number} If there is no handler for resizing, this is the thickness of 
 *                   | the container corner which still triggers resizing.
 *
 * \endcode
 */
Zapatec.Utils.Resizable = function(config) {
	Zapatec.Utils.Resizable.SUPERconstructor.call(this, config);
};

Zapatec.Utils.Resizable.id = "Zapatec.Utils.Resizable";
Zapatec.inherit(Zapatec.Utils.Resizable, Zapatec.Utils.Sizable);
Zapatec.implement(Zapatec.Utils.Resizable, "Zapatec.Movable");
Zapatec.implement(Zapatec.Utils.Resizable, "Zapatec.Resizable");

/**
 * Inits the object with set of config options.
 * @param config {object} configuration parameters.
 */
Zapatec.Utils.Resizable.prototype.init = function(config) {
	//calling parent init
	Zapatec.Utils.Resizable.SUPERclass.init.call(this, config);
	this.restoreOfSizing();
	//makes object resizable 
	this.makeResizable();
};

/**
 * Sets the default configuration of the object and
 * inits it with user defined values.
 * @param config {object} configuration parameters.
 */
Zapatec.Utils.Resizable.prototype.configure = function(config) {
	//method of resizing
	this.defineConfigOption("method", "self");
	//should we stop mouse down event!
	this.defineConfigOption("stopEvent", true);
	//the handlers for resizing
	this.defineConfigOption("handlers", null);
	//the border thickness for resizing, when no handler is ussed
	this.defineConfigOption("borderThickness", 10);
	//the corner thickness for resizing, when no handler is ussed
	this.defineConfigOption("cornerThickness", 10);
	//direction of resizing
	this.defineConfigOption("direction", "all");
	// Call parent method
	Zapatec.Utils.Resizable.SUPERclass.configure.call(this, config);
	config = this.getConfiguration();
	//correcting handlers option
	config.handlers = Zapatec.Array(config.handlers);
	config.handlers.each(function(index, handler) {
		handler = Zapatec.Widget.getElementById(handler);
		handler = Zapatec.Utils.img2div(handler);
		config.handlers[index] = handler;
	});
};

/**
 * Reconfigures the object with new parameters.
 * @param config {object} new configuration parameters.
 */
Zapatec.Utils.Resizable.prototype.reconfigure = function(config) {
	// Call parent method
	Zapatec.Utils.Resizable.SUPERclass.reconfigure.call(this, config);
};

/**
 * Returns the handlers.
 * @return {array} handler elements.
 */
Zapatec.Utils.Resizable.prototype._getResizableHooks = function() {
	return this.getConfiguration().handlers;
};
// $Id: indicator.js 6596 2007-03-13 09:09:25Z slip $
/*
 * <pre>
 * Copyright (c) 2004-2006 by Zapatec, Inc.
 * http://www.zapatec.com
 * 1700 MLK Way, Berkeley, California,
 * 94709, U.S.A.
 * All rights reserved.
 * </pre>
 */

/**
 * Zapatec modal object.
 * It represents the element that imitates
 * modal behaviour.
 *
 * The constructor recognizes the following options:
 * \code
 *    prop. name     | description
 *  -------------------------------------------------------------------------------------------------
 *   zIndex          | {number} z-index for the element. Default 1000.
 *   x               | {number} X coordinate of the element. Default null.
 *   y               | {number} Y coordinate of the element. Default null.
 *   width           | {number} width of the element. Default null.
 *   height          | {number} height of the element. Default null.
 *   container       | {HTML element or Default View} container for the element. Default window.
 *   scroll          | {boolean} if the element is fixed on screen. Default false.
 *   
 * \endcode
 */
Zapatec.Modal = function (config) {
	if (arguments.length == 0) {
		config = {};
	}
	//visibility is false on start
	this.visible = false;
	//calling super constructor
	Zapatec.Modal.SUPERconstructor.call(this, config);
}

//assigning ID
Zapatec.Modal.id = "Zapatec.Indicator";

// Inherit SuperClass
Zapatec.inherit(Zapatec.Modal, Zapatec.Widget);

/**
 * Inits the object with config options.
 * @param config {object} object with configuration.
 */
Zapatec.Modal.prototype.init = function(config){
	// processing Widget functionality
	Zapatec.Modal.SUPERclass.init.call(this, config);
};

/**
 * Configurates the object.
 * @param config {object} object with configuration.
 */
Zapatec.Modal.prototype.configure = function(config) {
	//z-index
	this.defineConfigOption("zIndex", 1000);
	//x coordinate
	this.defineConfigOption("x", null);
	//y coordinate
	this.defineConfigOption("y", null);
	//width
	this.defineConfigOption("width", null);
	//height
	this.defineConfigOption("height", null);
	//container of the modal cover
	//IMPORTANT NOTE: if container is not window
	//x, y, width and height params are ignored
	//and modal tries to stick to it.
	this.defineConfigOption("container", window);
	//if modal is fixed on the screen
	this.defineConfigOption("fixed", false);
	// processing Widget functionality
	Zapatec.Modal.SUPERclass.configure.call(this, config);
	//getting configuration
	config = this.getConfiguration();
	//checking container
	if (config.container != window) {
		config.x = null;
		config.y = null;
		config.width = null;
		config.height = null;
		config.fixed = false;
	}
};

/**
 * Creates the actual element and assigns
 * classes and styles to it.
 */
Zapatec.Modal.prototype.create = function () {
	//trying to get config.container
	var config = this.getConfiguration();
	config.container = Zapatec.Widget.getElementById(config.container) || window;
	//creating WCH
	this.WCH = Zapatec.Utils.createWCH();

	//creating container
	this.container = Zapatec.Utils.createElement("div", document.body);
	//applying theme
	this.container.className = this.getClassName({prefix: "zpModal" + (Zapatec.is_opera ? "Opera" : "")})
	//making it absolutely positioned
	var st = this.container.style;
	st.dispaly = "none";
	st.position = "absolute";
	st.zIndex = config.zIndex;
};

/**
 * Shows the modal cover, creates it
 * if it still wasn't.
 * @param zIndex {number} z-ndex for the cover.
 */
Zapatec.Modal.prototype.show = function (zIndex) {
	//if modal element wasn't created let's do it
	if (!this.container) {
		this.create();
	}
	//setting new z-index
	zIndex = zIndex || this.config.zIndex;
	this.container.style.zIndex = zIndex;
	if (this.WCH) {
		this.WCH.style.visibility = "";
		this.WCH.style.zIndex = zIndex - 1;
	}
	//making it visible
	this.container.style.display = "block";
	//pointing that modal cover is visible
	this.visible = true;
	//getting configuration
	var config = this.getConfiguration();
	//if container is not window then we need start sticking
	if (config.container != window) {
		var self = this;
		//we try to update the size and position of
		//modal cover to cover container
		var update = function() {
			self.update();
		}
		if (!this.interval) {
			this.interval = setInterval(update, 100);
		}
		this.update();
	} else {
		//getting sizes
		var dim = Zapatec.Utils.getWindowSize();
		var width = config.width || dim.width;
		var height = config.height || dim.height;
		//getting position
		var x = config.x || Zapatec.Utils.getPageScrollX();
		var y = config.y || Zapatec.Utils.getPageScrollY();
		//setting sizes
		this.setWidth(width);
		this.setHeight(height);
		//setting position
		this.setPosition(x, y);
	}
	//fixating element if needed
	if(this.config.fixed == true){
		Zapatec.FixateOnScreen.register(this.container);
		if (this.WCH){
			Zapatec.FixateOnScreen.register(this.WCH);
		}
	}
};

/**
 * Updates the size and position of
 * modal cove due to container option.
 */
Zapatec.Modal.prototype.update = function() {
	var config = this.getConfiguration();
	if (config.container != window && this.visible) {
		var offs = Zapatec.Utils.getElementOffset(config.container);
		this.setWidth(offs.width);
		this.setHeight(offs.height);
		this.setPosition(offs.x, offs.y);
	}
};

/**
 * Hides the modal cover.
 * @param destroy {boolean} if true the cover will be destroyed.
 */
Zapatec.Modal.prototype.hide = function (destroy) {
	//getting configuration
	var config = this.getConfiguration();
	//unfixating element if needed
	if(config.fixed == true){
		Zapatec.FixateOnScreen.unregister(this.container);
		if (this.WCH){
			Zapatec.FixateOnScreen.unregister(this.WCH);
		}
	}
	//clearing interval
	if (config.container != window) {
		clearInterval(this.interval);
		this.interval = null;
	}
	//hiding elements
	if (this.container) this.container.style.display = "none";
	Zapatec.Utils.hideWCH(this.WCH);
	//destroying if needed
	if (destroy) {
		if (this.WCH){
			if (this.WCH.outerHTML) {
				this.WCH.outerHTML = "";
			} else {
				Zapatec.Utils.destroy(this.WCH);
			}
		}
		if (this.container.outerHTML) {
			this.container.outerHTML = "";
		} else {
			Zapatec.Utils.destroy(this.container);
		}
		this.WCH = null;
		this.container = null;
	}
	//pointing that modal cover is visible
	this.visible = false;
};

/**
 * Sets the width of the modal cover.
 * @param width {number} new width.
 */
Zapatec.Modal.prototype.setWidth = function(width) {
	if (!this.container) {
		return;
	}
	//if dom.js is included lets use its possibilities
	if (Zapatec.Utils.setWidth) {
		Zapatec.Utils.setWidth(this.container, width);
		Zapatec.Utils.setWidth(this.WCH, width);
	} else {
		//otherwise let's try to do it manually
		this.container.style.width = width + "px";
		if (this.WCH) {
			this.WCH.style.width = width + "px";
		}
	}
};

/**
 * Sets the height of the modal cover.
 * @param height {number} new height.
 */
Zapatec.Modal.prototype.setHeight = function(height) {
	if (!this.container) {
		return;
	}
	//if dom.js is included lets use its possibilities
	if (Zapatec.Utils.setHeight) {
		Zapatec.Utils.setHeight(this.container, height);
		Zapatec.Utils.setHeight(this.WCH, height);
	} else {
		//otherwise let's try to do it manually
		this.container.style.height = height + "px";
		if (this.WCH) {
			this.WCH.style.height = height + "px";
		}
	}
};

/**
 * Sets the position of the modal cover.
 * @param x {number} x coordinate of the cover.
 * @param y {number} y coordinate of the cover.
 */
Zapatec.Modal.prototype.setPosition = function(x, y) {
	if (!this.container) {
		return;
	}
	//if dom.js is included lets use its possibilities
	if (Zapatec.Utils.moveTo) {
		Zapatec.Utils.moveTo(this.container, x, y);
		Zapatec.Utils.moveTo(this.WCH, x, y);
	} else {
		//otherwise let's try to do it manually
		this.container.style.left = x + "px";
		this.container.style.top = y + "px";
		if (this.WCH) {
			this.WCH.style.left = x + "px";
			this.WCH.style.top = y + "px";
		}
	}
};

/**
 * Zapatec indicator object
 * The constructor recognizes same options 
 * as Zapatec.Modal constructor.
 */
Zapatec.Indicator = function (config) {
	if(arguments.length == 0){
		config = {};
	}

	//it is not active at start
	this.active = false;
	// processing Modal functionality
	Zapatec.Indicator.SUPERconstructor.call(this, config);
}

//assiging ID
Zapatec.Indicator.id = "Zapatec.Indicator";

// Inherit SuperClass
Zapatec.inherit(Zapatec.Indicator, Zapatec.Modal);

/**
 * Inits the object.
 * @param config {object} object with configuration.
 */
Zapatec.Indicator.prototype.init = function(config){
	// processing Modal functionality
	Zapatec.Indicator.SUPERclass.init.call(this, config);
};

/**
 * Configurates the object.
 * @param config {object} object with configuration.
 */
Zapatec.Indicator.prototype.configure = function(config) {
	//defining theme path
	this.defineConfigOption("themePath", Zapatec.zapatecPath + "../zpextra/themes/indicator/");
	// processing Modal functionality
	Zapatec.Indicator.SUPERclass.configure.call(this, config);
};

/**
 * Overwriting parent method.
 */
Zapatec.Indicator.prototype.create = function() {
	//calling parent method
	Zapatec.Indicator.SUPERclass.create.call(this);
	//creating indicator
	this.indicator = Zapatec.Utils.createElement("div", this.container);
	this.indicator.className = "zpIndicator";
	//styling it
	var st = this.indicator.style;
	st.position = "absolute";
	st.zIndex = this.getConfiguration().zIndex;
	st.backgroundColor = "#aaaaaa";
};

/**
 * Overwriting parent method.
 * @param width {number} width to set.
 */
Zapatec.Indicator.prototype.setWidth = function(width) {
	if (!this.container) {
		return;
	}
	//calling parent method
	Zapatec.Indicator.SUPERclass.setWidth.call(this, width);
	//updating indicator position.
	var left = Math.round((this.container.offsetWidth - this.indicator.offsetWidth) / 2);
	this.indicator.style.left = left + "px";
}; 

/**
 * Overwriting parent method.
 * @param height {number} height to set.
 */
Zapatec.Indicator.prototype.setHeight = function(height) {
	if (!this.container) {
		return;
	}
	//calling parent method
	Zapatec.Indicator.SUPERclass.setHeight.call(this, height);
	//updating indicator position.
	var top = Math.round((this.container.offsetHeight - this.indicator.offsetHeight) / 2);
	this.indicator.style.top = top + "px";
}; 

/**
 * Overwriting parent method.
 * @param destroy {boolean} if we destroy the indicator.
 */
Zapatec.Indicator.prototype.hide = function(destroy) {
	if (destroy) {
		this.indicator = null;
	}
	//calling parent method
	Zapatec.Indicator.SUPERclass.hide.call(this, destroy);
};

/**
 * Starts the indicator, filling it with some
 * message and showing. Also puts it to active state.
 * @param message {}
 */
Zapatec.Indicator.prototype.start = function (message) {
	//pointing that it is active
	this.active = true;
	if (!this.indicator) {
		this.create();
	}
	//fillig with message
	this.indicator.innerHTML = message;
	//showing it
	this.show();
};

/**
 * Stops the indicator.
 */
Zapatec.Indicator.prototype.stop = function () {
	//pointing that it is inactive
	this.active = false;
	//destroying it
	this.hide(true);
};

/**
 * Checks if indicator is active.
 * @return {boolean} true if it is active, otherwise false.
 */
Zapatec.Indicator.prototype.isActive = function () {
	return this.active;
};// $Id: pane.js 6781 2007-03-28 09:47:39Z slip $
/*
 * <pre>
 * Copyright (c) 2004-2006 by Zapatec, Inc.
 * http://www.zapatec.com
 * 1700 MLK Way, Berkeley, California,
 * 94709, U.S.A.
 * All rights reserved.
 * </pre>
 */

/**
* Zapatec Pane object. Creates the element for displaying content
* and gives an interface to work with it.
* @param config [object] - pane config.
*
* Constructor recognizes the following properties of the config object
* \code
*	property name		| description
*-------------------------------------------------------------------------------------------------
*	parent					| [string or object] Reference to DOM element where
*							| newly created Pane will be placed. By default -
*							| document.body
*	containerType			| [string] Required. Possible values: div|iframe|current -
*							| what type of pane to create
*							| * div - create new DIV element and add it into parent
*							| * iframe - create new IFRAME element and add it into parent
*							| * current - use parent as pane container
*	sourceType				| [string] see Zapatec.Widget documentation for this option
*	source					| [string or object] see Zapatec.Widget documentation
*							| for this option
*   width                   | [number] width of the Pane in "px"
*   height                  | [number] height of the Pane in "px"
*   autoContentWidth        | [boolean] Option which determines if the width of the Pane will be 
*                           | determined automatically.
*   autoContentHeight       | [boolean] Option which determines if the height of the Pane will be 
*                           | determined automatically.
*   id                      | [string] Optionally you can pass some string to be able to seek Pane by this ID
*   onlyInit                | [boolean] For developing needs this option will disable calling create method
*                           | of the Pane from init, so HTML structure will not be created after calling
*                           | constructor.
*   showLoadingIndicator    | [boolean] Determines if a loading progress indicator is to be shown
*                           | inside pane during loading. Default is true.
* \endcode
*/
Zapatec.Pane = function(objArgs){
	this.config = {};

	if(arguments.length == 0){
		objArgs = {};
	}
	
	//type of the widget - pane in our case :)
	this.widgetType = "pane";
	// internal variable that indicates if iframe was loaded
	this.ready = false;
	//is the content still loading
	this.loading = false;
	// internal variable to detect if Pane was prepared (prepareHtml was called)
	this.prepared = false;
	// variable to store reference to pane container
	Zapatec.Utils.createProperty(this, "container", null);
	// variable to store the reference to the content element
	Zapatec.Utils.createProperty(this, "contentElement", null);
	// internal variable stores reference to IFRAME's document object
	Zapatec.Utils.createProperty(this, "iframeDocument", null);
	//calling superconstructor
	Zapatec.Pane.SUPERconstructor.call(this, objArgs);
}

Zapatec.Pane.id = "Zapatec.Pane";

// Inherit SuperClass
Zapatec.inherit(Zapatec.Pane, Zapatec.Widget);

/**
* Init function. Actually this function does the creation of element
* itself, not the constructor.
*/
Zapatec.Pane.prototype.init = function(objArgs){
	//parent element of the Pane
	Zapatec.Utils.createProperty(this.config, "parent", document.body);
	//theme
	this.config.theme = null;
	//initial width
	this.config.width = null;
	//initial height
	this.config.height = null;
	//container type "div"/"iframe"/"current"
	this.config.containerType = "div";
	//content source type
	this.config.sourceType = null;
	//source to load content from
	this.config.source = null;
	//is the Pane resized due to its content
	this.config.autoContentWidth = false;
	this.config.autoContentHeight = false;
	//this option is used for disabling creation of HTML elements for the Pane.
	//Developer should manually call create method if he defines this option as true.
	this.config.onlyInit = false;
	this.config.showLoadingIndicator = true;

	// processing Widget functionality
	Zapatec.Pane.SUPERclass.init.call(this, objArgs);
	//default for containerType is "div"
	if(this.config.containerType == null){
		this.config.containerType = "div";
	}

	//caling create if enabled
	if (!this.config.onlyInit) {
		this.create(this.config.width, this.config.height);
	}
	var self = this;
	function update() {
		//if there is loader we need to update it
		if (self.loader) {
			self.loader.update();
		}
	}
	//updating loader
	this.addEventListener("fetchSourceStart", update);
	this.addEventListener("fetchSourceEnd", update);
}

/**
 * Creates all needed HTML elements, if we are not reusing parent.
 */
Zapatec.Pane.prototype.prepareHtml = function() {
	if(this.config.containerType.toLowerCase() == 'iframe'){
		// create new IFRAME element
		var iframe = document.createElement("iframe");
		iframe.src = Zapatec.zapatecPath + "pane_files/blank.html#" + this.id;
		//filling the container property
		this.container = iframe;
		iframe = null;
	} else if(this.config.containerType.toLowerCase() == 'div'){
		// create new DIV element
		this.container = document.createElement("div");
		this.contentElement = this.container;
	} else if (this.config.parent && this.config.parent.nodeType == 1) {
		this.container = this.config.parent;
		this.contentElement = this.container;
	}
	//flag to detect that this function was called
	this.prepared = true;
};
 
/**
 * Creates the HTML part of the Pane by calling prepareHtml, 
 * if it was not called before and adds the container to 
 * the document tree.
 * @param width [number] - optional, width that can be different from
 * the config's one
 * @param height [number] - optional, height that can be different from
 * the config's one
 */
Zapatec.Pane.prototype.create = function(width, height) {
	//if there was no preparation made we need to do it.
	//this is for separating operations that do depend
	//on body load from that which are indepenedent
	if (!this.prepared) {
		this.prepareHtml();
	}

	//searching Pane's parent
	if (!(this.config.parent = Zapatec.Widget.getElementById(this.config.parent))) {
		Zapatec.Log({description: "No reference to parent element."});
		return null;
	}
	//I need this kind of interface to be able to pass widget objects as
	//parent property of config.
	if (this.config.parent.requestParentFor && !(this.config.parent = this.config.parent.requestParentFor(this))) {
		Zapatec.Log({description: "No reference to parent element after request to the Parent Widget!"});
		return null;
	}

	//we can work with a container if it exists, otherwise we
	//need to reuse parent
	if (this.config.containerType.toLowerCase() == 'div' || 
	    this.config.containerType.toLowerCase() == 'iframe') {
			//appending it to the tree
			this.ready = false;
			this.config.parent.appendChild(this.container);
			//initing Pane to be ready for work
			if (this.config.containerType.toLowerCase() != 'iframe') {
				this.initPane();
			}
	} else if (this.config.containerType.toLowerCase() == 'current') {
		//reusing parent
		this.container = this.config.parent;
		this.contentElement = this.container;
		this.initPane();
	} else {
		Zapatec.Log({description: "Unknown container type: " + this.config.containerType + ". Possible values: iframe|div"})
	}
	//adding a theme className
	Zapatec.Utils.addClass(this.container, this.getClassName({prefix: "zpPane"}));
	//setting sizes
	if (width || this.config.width) {
		this.setWidth(width || this.config.width);
	}
	if (height || this.config.height) {
		this.setHeight(height || this.config.height);
	}
	this.getContainer().style.display = "block";
	this.setPaneContent();
};

/*
* \internal For containerType=iframe this function stores reference to internal
* document.body element and loads data from given source.
*/
Zapatec.Pane.prototype.initPane = function(){
	if(this.config.containerType.toLowerCase() == 'iframe'){
		var doc = null;
		//this variable determines if the Pane has the content from the same domain
		var sameDomain = true;
		//iframe's src
		var url = this.getContainer().src;
		//anchor element to make a workaround while calculating absolute URL from src
		var anchorEl = document.createElement("a");
		//is there a protocol definition in the SRC
		//cause if not than this must be the same domain
		//and we don't have to worry about anything
		var protocolSeparatorPos = url.indexOf("://");
	
		//if there is protocol definition than we must check 
		//if domain is the same as ours(I mean the page where we use the Pane)
		if (protocolSeparatorPos != -1) {
			//retreiving the domain
			var domainSeparatorPos = url.indexOf("/", protocolSeparatorPos + 3);
			var domain = url.substring(
				(protocolSeparatorPos > 0 ? protocolSeparatorPos + 3 : 0),
				(domainSeparatorPos > 0 ? domainSeparatorPos : url.length)
			);
			//checking if it is the same
			if (domain != window.location.host) {
				sameDomain = false;
			}
		}
		//if it is the same domain than we can easily work with its content
		//otherwise this.contentElement will be null and all methods
		//that are working with content will block their work
		if (sameDomain) {
			//checking if iframes document is avaliable
			if(this.container.contentDocument != null){
				doc = this.container.contentDocument;
			} else if(this.container.contentWindow && this.container.contentWindow.document != null){
				doc = this.container.contentWindow.document;
			}
	
			var self = this;
			//a workaround to get absolute url from src property
			anchorEl.href = url;
			url = anchorEl.href;
			//if iframe's document is unavaliable still 
			//fire this function again with some timeout	
			if (doc == null || doc.body == null || (Zapatec.is_gecko && url != this.container.contentWindow.location.href)) {
				setTimeout(function(){self.initPane()}, 50);
				return false;
			}
			// store reference to iframe's document
			this.iframeDocument = doc;
			this.contentElement = doc.body;
			if (typeof this.container.contentWindow.Zapatec != "object" && typeof this.container.contentWindow.Zapatec != "function") {
				this.container.contentWindow.Zapatec = {};
				this.container.contentWindow.Zapatec.windowLoaded = typeof(doc.readyState) != 'undefined' ?
					(
						doc.readyState == 'loaded' || // Konqueror
						doc.readyState == 'complete' // IE/Opera
					) :
					// Mozilla
					doc.getElementsByTagName != null && typeof(doc.getElementsByTagName('body')[0]) != 'undefined'
				;
				
				Zapatec.Utils.addEvent(this.container.contentWindow, "load", function() {self.container.contentWindow.Zapatec.windowLoaded = true;});
			}
			if (!this.container.contentWindow.Zapatec || !this.container.contentWindow.Zapatec.windowLoaded) {
				setTimeout(function(){self.initPane()}, 50);
				return false;
			}

			doc = null;
		}
	}

	//for now Pane has overflow "auto"
	//TODO: change this to be a config option
	this.getContainer().style.overflow = "auto";
	this.ready = true;
	//firing the ready event
	this.fireEvent("onReady", this);
	//hiding loader
	this.hideIndicator();
	//pointing the end of loading
	this.loading = false;
	//TODO: move this functionality to EventDriven or any other place
	this.removeEvent("onReady");
}

/*
* Returns reference to data container - do not use this element to resize it or
* do any other DOM changes!
*/
Zapatec.Pane.prototype.getContainer = function(){
	return this.container;
}

/*
* Returns reference to IFRAME's document object.
*/
Zapatec.Pane.prototype.getIframeDocument = function(){
	return this.iframeDocument;
}

/*
* Returns the element which represents the content
*/
Zapatec.Pane.prototype.getContentElement = function() {
	return this.contentElement;
}

/*
* Returns true if iframe was loaded succesfully
*/
Zapatec.Pane.prototype.isReady = function(){
	return this.ready;
}


/**
* Loads data from the HTML source.
* \param objSource [object] source HTMLElement object.
*/
Zapatec.Pane.prototype.loadDataJson = function(objSource){
	return objSource != null ? this.setContent(objSource.content) : null;
}

/**
* Sets the content of the pane.
* @param content [string or object] - string content or reference to DOM element
* @return [boolean] - true if successfull, otherwise false.
*/
Zapatec.Pane.prototype.setContent = function(content){
	if(!this.isReady()){
		// this can happen when containerType=iframe but it is not created yet.
		var self = this;
		setTimeout(function(){self.setContent(content)}, 50);
		return null;
	}
	//if there is no contentElement than this is an iframe with src from
	//another domain and we can not work with it
	this.loading = false;
	if (!this.getContentElement()) {
		this.hideIndicator();
		return false;
	}
	//no content no action :)
	if(content === null){
		this.hideIndicator();
		return null;
	} else {
		//if this is not iframe and we have auto sizes we need to allow the
		//content to be visible
		if (this.config.containerType.toLowerCase() != "iframe") {
			//saving old overflow
			var oldOverflow = this.getContainer().style.overflow;
			//setting needed sizes to "auto"
			if (this.config.autoContentWidth) {
				//setting overflow visible
				this.getContainer().style.overflow = "visible";
				this.getContainer().style.width = "auto";
			}
			if (this.config.autoContentHeight) {
				//setting overflow visible
				this.getContainer().style.overflow = "visible";
				this.getContainer().style.height = "auto";
			}
		}
		if(typeof(content) == 'string'){
			//setting new content if it is string
			Zapatec.Transport.setInnerHtml({container : this.getContentElement(), html : content});
		} else {
			try{
				//this is temporary fix for IE as it can not appendChild in iframe
				//when node was created not in iframe document
				if ((Zapatec.is_ie || Zapatec.is_opera) && this.config.containerType.toLowerCase() == "iframe") {
					Zapatec.Transport.setInnerHtml({container : this.getContentElement(), html : content.outerHTML});
				} else {
		        	// If content is not already added to container
		        	if (content.parentNode != this.getContentElement()) {
		        		//empty the element
		        		this.getContentElement().innerHTML = "";
		        		this.getContentElement().appendChild(content);
		        	}
		        }
			} catch(ex){
				this.hideIndicator();
				return null;
			}
		}
		//if this is not an iframe we get new sizes and set them as the size of Pane
		if (this.config.containerType.toLowerCase() != "iframe") {
			var newWidth = this.getWidth();
			var newHeight = this.getHeight();
		} else {
			//if this is iframe we are using scrollWidth and scrollHeight to resize iframe.
			//FIXME: This is not working correctly so needed to be fixed in new version
			var newWidth = this.getContentElement().scrollWidth + 5;
			var newHeight = this.getContentElement().scrollHeight + 5;
		}
		//restoreing overflow
		if (typeof oldOverflow != "undefined") this.getContainer().style.overflow = oldOverflow;
		//setting new sizes
		if (this.config.autoContentWidth) {
			this.setWidth(newWidth);
		}
		if (this.config.autoContentHeight) {
			this.setHeight(newHeight);
		}
	}
	//calling listeners for contentLoad event
	//use this to resize your widget which uses auto sizes feature of Pane
	this.fireEvent("contentLoaded", this);
	this.hideIndicator();
	return true;
}

/**
* Loads data from the HTML|Xml fragment source.
* \param strSource [string] source HTML fragment.
*/
Zapatec.Pane.prototype.loadDataHtml = Zapatec.Pane.prototype.loadDataXml = Zapatec.Pane.prototype.setContent;

Zapatec.Pane.prototype.loadDataHtmlText = function(content) {
	this.setContent(content);
};

/*
* Set pane width
* \param width [int] - width to set.
*/
Zapatec.Pane.prototype.setWidth = function(width){
	var self = this;
	this.fireWhenReady(function() {
		self.getContainer().style.width = width + "px";
		//we do this to have the size passed be equal to offset size
		if (self.getContainer().offsetWidth != width) {
			var newWidth = width - (self.getContainer().offsetWidth - width);
			if (newWidth < 0) newWidth = 0;
			self.getContainer().style.width = newWidth + "px";
		}
	});
}

/*
* Returns pane width
*/
Zapatec.Pane.prototype.getWidth = function(){
	return this.getContainer().offsetWidth;
}

/*
* Set pane height
* \param height [int] - height to set.
*/
Zapatec.Pane.prototype.setHeight = function(height){
	var self = this;
	this.fireWhenReady(function() {
		self.getContainer().style.height = height + "px";
		//we do this to have the size passed be equal to offset size
		if (self.getContainer().offsetHeight != height) {
			var newHeight = height - (self.getContainer().offsetHeight - height);
			if (newHeight < 0) newHeight = 0;
			self.getContainer().style.height = newHeight + "px";
		}
	});
}

/*
* Returns pane height
*/
Zapatec.Pane.prototype.getHeight = function(){
	return this.getContainer().offsetHeight;
}

/*
 * Removes the border for iframe.
 */
Zapatec.Pane.prototype.removeBorder = function() {
	if (this.config.containerType.toLowerCase() != "iframe") {
		return false;
	}
	var self = this;
	this.fireWhenReady(function() {
		//trying to remove border
		if (!Zapatec.is_ie) {
			self.getContainer().style.border = "none";
		} else {
			if (self.getContentElement()) {
				self.getContentElement().style.border = "none";
			}
		}
	});
};

/* The method to cover setting of content. Simply it sets the content
 * depending on its type.
 * @param content [mixed] - value for the content
 * @param type [string] - type of content: "html", "html/text", "html/url"
 * @return [boolean] - true if successfull, otherwise false.
 */
Zapatec.Pane.prototype.setPaneContent = function(content, type) {
	//if we have no arguments passed we need to set default
	//ones from config
	if (!content && content !== "") {
		content = this.config.source;
	}
	if (!type) {
		type = this.config.sourceType;
	}
	//we need to save the content description for reloading
	this.config.source = content;
	this.config.sourceType = type;
	//if containerType == "iframe" and we are seting its content from URL, 
	//we should use its SRC attribute
	var self = this;
	// If loading indicator is enabled
	if (this.config.showLoadingIndicator) {
		this.showIndicator();
		this.loading = true;
	}
	if (this.config.containerType.toLowerCase() == "iframe" && type == "html/url") {
		this.ready = false;
		this.fireWhenReady(function() {
			//if Pane have auto sizes we need to set them
			if (self.getContentElement()) {
				try {
					var newWidth = self.getContentElement().scrollWidth;
					var newHeight = self.getContentElement().scrollHeight;
					if (self.config.autoContentWidth) {
						self.setWidth(newWidth);
					}
					if (self.config.autoContentHeight) {
						self.setHeight(newHeight);
					}
				} catch(e) {}
			}		
			self.fireEvent("contentLoaded", self);
			if (self.events["contentLoaded"]) {
				self.events["contentLoaded"].listeners = [];
			}
		});
		this.getContainer().src = content;
		setTimeout(function(){self.initPane()}, 50);
		
		return true;
	}

	if (this.config.containerType.toLowerCase() == "iframe" && this.getContainer().src.indexOf((Zapatec.zapatecPath + "pane_files/blank.html#" + this.id).replace(/\.\.\//g, "")) < 0) {
		this.ready = false;
		this.getContainer().src = Zapatec.zapatecPath + "pane_files/blank.html#" + this.id;
	}

	//otherwise we use zpwidget's possibilities
	this.loadData();
	
	return true;
};

/**
 * Shows the Pane container.
 */
Zapatec.Pane.prototype.show = function() {
	this.getContainer().style.display = "";
	if (this.loading) {
		this.showIndicator();
	}
};

/**
 * Hides the Pane container.
 */
Zapatec.Pane.prototype.hide = function() {
	this.getContainer().style.display = "none";
	if (this.loading) {
		this.hideIndicator();
	}
};

/**
 * Shows the indicater.
 * @param message {string} message to show.
 */
Zapatec.Pane.prototype.showIndicator = function(message) {
	if (Zapatec.Indicator) {
		this.hideIndicator();
		//creating loader
		if (!this.loader) {
			this.loader = new Zapatec.Indicator({
				container: this.container,
				themePath: Zapatec.zapatecPath + "../zpextra/themes/indicator/"
			});
		}
		this.loader.start(message || 'loading');
	}
};
 
/**
 * Hides the indicater.
 */
Zapatec.Pane.prototype.hideIndicator = function() {
	if (this.loader && this.loader.isActive()) {
		this.loader.stop();
	}
};

/* 
 * Fires the action when widget is ready.
 * @param func [function] - the function to be fired when the widget is ready
 */
Zapatec.Pane.prototype.fireWhenReady = function(func) {
	if (!this.isReady()) {
		this.addEventListener("onReady", func);
	} else {
		func.call(this, this);
	}
}

/**
* Destroys current pane instance removing all related HTML elements.
*/

Zapatec.Pane.prototype.destroy = function(){
	this.hideIndicator();
	this.config.parent = null;
	this.contentElement = null;
	this.iframeDocument = null;
	if(Zapatec.is_ie && this.config.containerType.toLowerCase() == 'iframe'){
		this.container.src = "javascript:void(0)";
	}

	if (this.container.outerHTML) {
		this.container.outerHTML = "";
	} else {
		Zapatec.Utils.destroy(this.container);
	}
	this.container = null;
	this.ready = false;
	this.prepared = false;
}
// $Id: window-core.js 6642 2007-03-18 09:27:06Z slip $
/**
 *
 * Copyright (c) 2004-2006 by Zapatec, Inc.
 * http://www.zapatec.com
 * 1700 MLK Way, Berkeley, California,
 * 94709, U.S.A.
 * All rights reserved.
 */

/**
 * The Window object constructor.  Call it, for example, like this:
 *
 * \code
 *   var win = new Zapatec.Window({
 *   	showResize : false
 *   });
 * \endcode
 *
 * The above creates a new Window object.  The Window isn't displayed
 * instantly; using the "win" variable, the programmer can now set certain
 * configuration variables, hook his own event handlers and then display the
 * window using Zapatec.Window.create() and Zapatec.Window.show().
 *
 * @param config [object] - all parameters are passed as the properties of this object.
 * 
 * Constructor recognizes the following properties of the config object
 * \code
 *    prop. name     | description
 *  -------------------------------------------------------------------------------------------------
 *   showMinButton   | whether to show minimize button (default true).
 *   showMaxButton   | whether to show maximize button (default true).
 *   showCloseButton | whether to show close button (default true).
 *   showStatus      | whether to show status bar text (default true).
 *   canResize       | whether to show resize icon (default true).
 *   raiseOnlyOnTitle| whether to raize when clicking on title or on the whole body of the created window (default false).
 *   canDrag         | whether you can drag the window (default true).
 *   modal           | if true modal window will be created (default false).
 *   onClose         | custom handler, will be called when window is closed. Depricated use eventListeners 
 *                   | option instead. See Zapatec.Widget documentation.
 *   onRestore       | custom handler, will be called when restore button is clicked. Depricated use eventListeners 
 *                   | option instead. See Zapatec.Widget documentation.
 *   onMinimize      | custom handler, will be called when min button is clicked. Depricated use eventListeners 
 *                   | option instead. See Zapatec.Widget documentation.
 *   onMaximize      | custom handler, will be called when max button is clicked. Depricated use eventListeners 
 *                   | option instead. See Zapatec.Widget documentation.
 *   onShow          | custom handler, will be called when show method is called. Depricated use eventListeners 
 *                   | option instead. See Zapatec.Widget documentation.
 *   onHide          | custom handler, will be called when hide method is called. Depricated use eventListeners 
 *                   | option instead. See Zapatec.Widget documentation.
 *   onResize        | custom handler, will be called when window is resized. Depricated use eventListeners 
 *                   | option instead. See Zapatec.Widget documentation.
 *   onRaise         | custom handler, will be called when window is raized. Depricated use eventListeners 
 *                   | option instead. See Zapatec.Widget documentation.
 *   onContentLoad   | custom handler, will be called when content is loaded. Depricated use eventListeners 
 *                   | option instead. See Zapatec.Widget documentation.
 *   minWidth        | minimal width of the window. Depricated use "limit" option instead.
 *   minHeight       | minimal height of the window. Depricated use "limit" option instead.
 *   iframeContent   | type of the content element.
 *   hideOnClose     | whether we destroy the window or just close
 *   dragMin         | is minimized draggable or not (default false)
 *   bottomMinimize  | is the window minimized to the bottom or just stay at its position
 *   
 * \endcode
 */
Zapatec.Window = function (config) {
	//the reference to the root HTML element of the window
	this.container = null;
	//reference to the element which holds the title bar
	this.titleArea = null;
	//reference to the element which holds the title text
	this.titleText = null;
	//reference to the Zapatec.Button object representing minimize button
	this.minButton = null;
	//reference to the Zapatec.Button object representing maximize button
	this.maxButton = null;
	//reference to the Zapatec.Button object representing close button
	this.closeButton = null;
	//reference to the Zapatec.Pane object representing content of the window
	this.content = null;	
	//reference to the element holding status area element
	this.statusText = null;
	//reference to the Modal object of this window
	this.modal = null;
	//flag which determines if the window is resizing
	this.resizing = false;
	//type of the widget - window in our case :)
	this.widgetType = "window";
	//widget privillage modes
	this.widgetModes = {};
	//high priority events
	this.highPriorityEvents = [];
	//delayed events
	this.delayedEvents = [];
	//this variable points the state of the widget in general.
	//The widget has a set of states 4 of them should go one after another ('created' -> 'inited' -> 'loaded' -> 'ready')
	//and point to the stage of creation of widget. Last one should be 'ready', 
	//which means a fully ready for work widget. Each of the methods can require
	//the state to be not lower than it needs. So we will also define a method
	//to work with this variable - stateReached(state) - to get true if state reached or passed.
	this.widgetState = "created";
	//array of priorities for states, in other words its the number which points the order
	// of states to be passed.
	this.priorities = {
		//the number of states supported
		count : 7,
		//states priorities
		destroyed : 0,
		created : 1,
		inited : 2,
		loaded : 3,
		ready : 4,
		hidden : 5,
		shown : 6
	};
	this.setDefaultState();
	//for backward compability
	if (!config.eventListeners) {
		config.eventListeners = {};
	}
	if (config.onClose) {config.eventListeners.onClose = config.onClose;}
	if (config.onRestore) {config.eventListeners.onRestore = config.onRestore;}
	if (config.onMaximize) {config.eventListeners.onMaximize = config.onMaximize;}
	if (config.onMinimize) {config.eventListeners.onMinimize = config.onMinimize;}
	if (config.onShow) {config.eventListeners.onShow = config.onShow;}
	if (config.onHide) {config.eventListeners.onHide = config.onHide;}
	if (config.onResize) {config.eventListeners.onResize = config.onResize;}
	if (config.onRaise) {config.eventListeners.onRaise = config.onRaise;}
	if (config.onContentLoad) {config.eventListeners.onContentLoad = config.onContentLoad;}
	config = Zapatec.Hash.remove(config, 
		"onClose", "onRestore", "onMaximize", "onMinimize",
		"onShow", "onHide", "onResize", "onRaise", "onContentLoad"
	);
	//calling super constructor
	Zapatec.Window.SUPERconstructor.call(this, config);
	//creating SRProp object for manipulating with our object
	this.restorer = new Zapatec.SRProp(this);
};

Zapatec.Window.id = "Zapatec.Window";

//Inheriting Zapatec.Widget class
Zapatec.inherit(Zapatec.Window, Zapatec.Widget);
//Implementing Zapatec.CommandEvent interface
Zapatec.implement(Zapatec.Window, "Zapatec.CommandEvent");
//Implementing Zapatec.Movable interface
Zapatec.implement(Zapatec.Window, "Zapatec.Movable");
//Implementing Zapatec.Draggable interface
Zapatec.implement(Zapatec.Window, "Zapatec.Draggable");
//Implementing Zapatec.Sizable interface
Zapatec.implement(Zapatec.Window, "Zapatec.Sizable");
//Implementing Zapatec.Resizable interface
Zapatec.implement(Zapatec.Window, "Zapatec.Resizable");

/**
 * This function inits the config object and loads HTML structure
 * of the window, not to waste time :)
 * @param config [object] - object which holds the configuration, same as for constructor
 */
Zapatec.Window.prototype.init = function(config) {
	// processing Widget functionality
	Zapatec.Window.SUPERclass.init.call(this, config);
	//action to be fired when privileged execution is on
	this.addEventListener("privileged_execution_on", function() {
		//array of high priority events
		this.highPriorityEvents = [];
	});
	//action to be fired when privileged execution is off
	this.addEventListener("privileged_execution_off", function() {
		//putting high priority events into the begining of array
		for (var ii = this.highPriorityEvents.length - 1; ii >= 0; --ii) {
			//if there is listener and it was not executed moving it to events array
			if (this.highPriorityEvents[ii] && !this.highPriorityEvents[ii].executed) {
				this.addEventListener(this.highPriorityEvents[ii].state, this.highPriorityEvents[ii].listener, true);
			}
		}
		//clearing array
		this.highPriorityEvents = [];
	});
	//action to be fired when delayed execution is on
	this.addEventListener("delayed_execution_on", function() {
		//array of delayed events
		this.delayedEvents = [];
	});
	//action to be fired when delayed execution is off
	this.addEventListener("delayed_execution_off", function() {
		//trying to execute or schedule delayed events
		for (var ii = this.delayedEvents.length - 1; ii >= 0; --ii) {
			//trying to schedule delayed event
			if (!this.fireOnState(this.delayedEvents[ii].state, this.delayedEvents[ii].listener)) {
				continue;
			}
			//otherwise executing it
			this.delayedEvents[ii].listener();
		}
	});
	//listener to activate Window on drag start
	//also sets the status message for dragging
	this.addEventListener("beforeDragInit", function() {
		this.activate();
		if (this.getConfiguration().method == "cut") {
			this.setStatus('drag the window', 'temp');
		}
	});
	//tries to remember dummy position
	var pos = null;
	this.addEventListener("beforeDragEnd", function() {
		if (this.getConfiguration().method != "cut") {
			pos = this.getPosition();
		}
	});
	//resets status on drag end
	this.addEventListener("onDragEnd", function() {
		if (this.getConfiguration().method == "cut") {
			this.setStatus('', 'restore');
		} else {
			this.setPosition(pos.x, pos.y);
		}
	});
	//listener to activate Window on resize start
	//also sets the status message for resizing
	this.addEventListener("onResizeInit", function() {
		this.activate();
		this.setStatus('resize the window', 'temp');
	});
	//resets status on resize end
	this.addEventListener("onResizeEnd", function() {
		this.setStatus('', 'restore');
	});
	//changing state to "inited"
	this.changeState("inited");
	//loading template for Window
	this.loadData({object : this, action : "loadTemplate"});
};

/**
 * Sets the default configuration of the object and
 * inits it with user defined values.
 * @param config {object} configuration parameters.
 */
Zapatec.Window.prototype.configure = function(config) {
	//wether title is visible
	this.defineConfigOption("showTitle", true);
	//wethter min button is visible
	this.defineConfigOption("showMinButton", true);
	//wethter max button is visible
	this.defineConfigOption("showMaxButton", true);
	//wethter close button is visible
	this.defineConfigOption("showCloseButton", true);
	//wethter status bar is visible
	this.defineConfigOption("showStatus", true);
	//wethter window is resizable
	this.defineConfigOption("canResize", true);
	//resizing directions
	this.defineConfigOption("resizeDirection", "all");
	//wether to raise only on clicking the title
	this.defineConfigOption("raiseOnlyOnTitle", false);
	//wether window is draggable
	this.defineConfigOption("canDrag", true);
	//dragging method
	this.defineConfigOption("dragMethod", "cut");
	//dragging class name (applied only when dragging)
	this.defineConfigOption("addDragCSS", null);
	//dragging class name (applied only when dragging, overwrites all others)
	this.defineConfigOption("newDragCSS", null);
	//wether window is modal
	this.defineConfigOption("modal", false);
	//limitations on the window
	this.defineConfigOption("limit", {
		minWidth : 120,
		maxWidth : null,
		minHeight : 120,
		maxHeight : null,
		minX : null,
		maxX : null,
		minY : null,
		maxY : null
	});
	//should we show content in IFRAME Pane or just simple div Pane
	this.defineConfigOption("iframeContent", false);
	//do we hide on close or destroy
	this.defineConfigOption("hideOnClose", false);
	//is minimized window draggable
	this.defineConfigOption("dragMin", false);
	//do we minimize to the bottom
	this.defineConfigOption("bottomMinimize", true);
	//is Window position fixed on the page
	this.defineConfigOption("fixed", false);
	//default theme winxp
	this.defineConfigOption("theme", "winxp");
	//we need the HTML part of our window to be loaded, so defining the source and sourceType
	this.defineConfigOption("template", Zapatec.Window.path + "struc.html");
	//callback source function
	this.defineConfigOption("callbackSource", function(args) {
		//getting window object that requested the load
		var win = args.object;
		//not a Zapatec.Window - no load
		if (!win || win.widgetType != "window") {
			return null;
		}
		switch (args.action) {
			//action is loading template
			case "loadTemplate" : {
				return {source : win.getConfiguration().template, sourceType : "html/url"};
			}
		}
		return null;
	});
	// processing Widget functionality
	Zapatec.Window.SUPERclass.configure.call(this, config);
	config = this.getConfiguration();
	if (config.dragMethod == "copy" || config.dragMethod == "dummy") {
		config.dragMethod = "dummy";
		config.newDragCSS = "zpWinDummy";
	}
};

/**
 * Reconfigures the object with new parameters.
 * @param config {object} new configuration parameters.
 */
Zapatec.Window.prototype.reconfigure = function(config) {
	// Call parent method
	Zapatec.Window.SUPERclass.reconfigure.call(this, config);
};

/**
 * We overwrite the zpwidgets loadDataHtml method to parse 
 * needed values from given HTML source.
 * @param el [HTML element] - DOM representation of or HTML part.
 */
Zapatec.Window.prototype.loadDataHtml = function(el) {
	//el is an DOM element created from the struct.html file, which contains HTML part of this widget.
	if (this.parseDom(el)) {
		this.changeState("loaded");
	}
};

/**
 * This function appends the loaded structure to the documents BODY,
 * makes Window draggable, sets all the parameters of the visual elements.
 * All its actions are closely connected with config options.
 * @param x [integer] x coordinate.
 * @param y [integer] y coordinate.
 * @param width [integer] width of the window.
 * @param height [integer] height of the window.
 */
Zapatec.Window.prototype.create = function (x, y, width, height)  {
	//parsing numbers for coordinates and sizes
	if (x != "center") {
		x = parseInt(x, 10) || 0;
	}
	if (y != "center") {
		y = parseInt(y, 10) || 0; 
	}
	if (width != "auto") {
		width = parseInt(width, 10) || 0; 
	}
	if (height != "auto") {
		height = parseInt(height, 10) || 0;
	}
	//If not everything is ready for creating the widget we should wait a little and try again.
	//some kind of imitation of "threaded widget", if you know what I mean :)
	if (!this.fireOnState("body_loaded", function() {this.create(x, y, width, height);}) || !this.fireOnState("loaded", function() {this.create(x, y, width, height);})) {
		return;
	}
	//appending the loaded element
	document.body.appendChild(this.getContainer());
	//adding a class name for using specified theme
	Zapatec.Utils.addClass(this.getContainer(), this.getClassName({prefix : "zpWin", suffix : "Container"}));
	//adding buttons
	function replaceButton(but, idPrefix, func) {
		//creating Zapatec.Button
		var button = new Zapatec.Button({
			className : but.className,
			style : but.style.cssText,
			theme : null,
			idPrefix : idPrefix,
			clickAction : func
		});
		//replaceing old one
		var nxtSbl = but.nextSibling;
		var par = but.parentNode;
		if (but.outerHTML) {
			but.outerHTML = "";
		} else {
			par.removeChild(but);
		}
		//putting new button
		par.insertBefore(button.getContainer(), nxtSbl);
		//returning new object
		return button;
	}
	var self = this;
	//min button
	this.minButton = replaceButton(this.minButton, "zpWin" + self.id + "MinButton", function() {self.minimize();});
	//max button
	this.maxButton = replaceButton(this.maxButton, "zpWin" + self.id + "MaxButton", function() {self.maximize();});
	//close button
	this.closeButton = replaceButton(this.closeButton, "zpWin" + self.id + "CloseButton", function() {self.close();});
	//restore button
	this.restoreButton = replaceButton(this.restoreButton, "zpWin" + self.id + "RestoreButton", function() {self.restore();});
	//customizing the structure to the options of config
	this.setModeOn("immediate_execution");
	this.reconfig();
	this.setModeOff("immediate_execution");
	//saving width of the old content
	var contentWidth = Zapatec.Utils.getWidth(this.content);
	//Creating a Pane object
	var pane = new Zapatec.Pane({
		containerType : (this.config.iframeContent ? "iframe" : "div")
	});
	this.content.getContainer = function() {return this;};
	//Currently we will not set width auto, we'll do it
	//on content load
	if (width == "auto") {
		width = 0;
		this.addEventListener("onContentLoad", function() {
			this.setWidth("auto");
			this.removeEventListener("onContentLoad", arguments.callee);
		});
	}
	if (height == "auto") {
		height = 0;
		this.addEventListener("onContentLoad", function() {
			this.setHeight("auto");
			this.removeEventListener("onContentLoad", arguments.callee);
		});
	}
	//copying class name
	pane.getContainer().className = this.content.className;
	//FIXME : these are also some tricks
	pane.fireWhenReady(function() {
		//removing margin and padding
		if (this.getContentElement()) {
			if (this.config.containerType.toLowerCase() == "iframe") {
				this.getContentElement().style.padding = "0px";
			}
			this.getContentElement().style.margin = "0px";
		}
		//removing border
		var width = Zapatec.Utils.getWidth(this.getContainer());
		this.removeBorder();
		Zapatec.Utils.setWidth(this.getContainer(), width);
	});
	//Creating WCH
	this.createProperty(this, "WCH", Zapatec.Utils.createWCH());
	if (this.WCH) {
		//puting WCH to right place
		this.WCH.style.zIndex = Zapatec.Window.maxNumber++;
		Zapatec.Utils.setWidth(this.WCH, Zapatec.Utils.getWidth(this.getContainer()));
		Zapatec.Utils.setHeight(this.WCH, Zapatec.Utils.getHeight(this.getContainer()));
		var pos = Zapatec.Utils.getElementOffset(this.getContainer());
		Zapatec.Utils.moveTo(this.WCH, pos.x, pos.y);
	}
	//manipulating with container
	this.container.style.zIndex = Zapatec.Window.maxNumber++;
	//making Window movable
	this.makeMovable();
	//making Window sizable
	this.makeSizable();
	//making Window draggable
	this.makeDraggable();
	//making Window resizable
	this.makeResizable();
	//replacing content with pane
	var content = this.content;
	this.content = pane;
	this.replaceWithSizable(content, this.content.getContainer());
	//adding "onContentLoad" event listener launch
	this.content.addEventListener("contentLoaded", function() {
		self.fireEvent('onContentLoad');
	});
	//adding a button type for titleArea to react on dbl click
	this.titleArea.buttonType = "title";
	//adding a button type for content not to cancel selection
	this.content.getContainer().buttonType = "content";
	//adding a button type for container to limit seeking of target element
	this.getContainer().buttonType = "container";
	//adding event listeners
	this.addEvents();
	//turning on immediate execution
	this.setModeOn("immediate_execution");
	//trying to set sizes and pos by our methods
	this.setSize(
		width > this.getConfiguration().limit.minWidth ? width : this.getConfiguration().limit.minWidth, 
		height > this.getConfiguration().limit.minHeight ? height : this.getConfiguration().limit.minHeight 
	);
	if (this.getConfiguration().fixed) {
		Zapatec.FixateOnScreen.register(this.getContainer());
		Zapatec.FixateOnScreen.register(this.WCH);
	}
	this.setScreenPosition(x, y);
	//hiding new window
	this.hide();
	//turning off immediate execution
	this.setModeOff("immediate_execution");
	//setting the state to ready
	this.changeState("ready");
};// $Id: window-controlling.js 6767 2007-03-27 08:21:54Z slip $
/**
 *
 * Copyright (c) 2004-2006 by Zapatec, Inc.
 * http://www.zapatec.com
 * 1700 MLK Way, Berkeley, California,
 * 94709, U.S.A.
 * All rights reserved.
 */

/**
 * Gets the window container.
 */
Zapatec.Window.prototype.getContainer = function() {
	return this.container;
};

/**
 * Sets default state values of the widget.
 */
Zapatec.Window.prototype.setDefaultState = function() {
	//stores the properties which describe the state of the widget
	this.state = {};
	//is window minimized, maximized or simple
	this.state.state = "simple";
	//X coordinate
	this.state.left = 0;
	//Y coordinate
	this.state.top = 0;
	//the width of the window
	this.state.width = 0;
	//the height of the window
	this.state.height = 0;
	//the content type of the window
	this.state.contentType = "";
	//the content of the window
	this.state.content = "";
};

/**
 * Updates the state object.
 */
Zapatec.Window.prototype._updateState = function() {
	//getting position
	var pos = null;
	if (!this.getConfiguration().fixed) {
		pos = this.getPosition();
	} else {
		pos = this.getScreenPosition();
	}
	//saving coordinates
	this.state.left = pos.x;
	this.state.top = pos.y;
	//saving sizes
	if (this.state.state != "min") {
		this.state.width = this.getWidth();
		this.state.height = this.getHeight();
	}
};

/** 
 * Gets the state of the window.
 * @return object with the following properties:
 * \code
 *    prop. name     | description
 *  -------------------------------------------------------------------------------------------------
 *   x       | left coordinate.
 *   y       | top coordinate.
 *   width   | width of container.
 *   height  | height of container.
 *   url     | if content is set from URL, than it contains that URL, otherwise null
 *   div     | if content is set from DIV element, than it contains it id, if it has no id its null.
 *   text    | if content is set as text string, than it contains that text, otherwise null
 * \endcode
 */
Zapatec.Window.prototype.getState = function() {
	var state = {};
	//getting coordinates
	state.x = this.state.left;
	state.y = this.state.top;
	//getting sizes
	state.width = this.state.width;
	state.height = this.state.height;
	//getting zIndex
	state.zIndex = this.getContainer().style.zIndex;
	//getting content
	switch(this.state.contentType) {
		case "html/text" : state.text = this.state.content; break;
		case "html" : state.div = this.state.content; break;
		case "html/url" : state.url = this.state.content; break;
	}
	
	return state;
};

/** 
 * Sets the state of the window.
 * @param state [object] with the following properties:
 * \code
 *    prop. name     | description
 *  -------------------------------------------------------------------------------------------------
 *   x       | left coordinate.
 *   y       | top coordinate.
 *   width   | width of container.
 *   height  | height of container.
 *   url     | URL content.
 *   div     | content is set from DIV element.
 *   text    | content is set as text string.
 * \endcode
 */
Zapatec.Window.prototype.setState = function(state) {
	if (!this.fireOnState("ready", function() {this.setState(state);})) {return;}
	//setting size and coordinates
	if (state.x || state.y || state.width || state.height) {
		this.setPosAndSize(state.x, state.y, state.width, state.height);
	}
	//setting z-index
	if (state.zIndex) {
		//for container
		this.container.style.zIndex = state.zIndex;
		//updating global variable
		if(state.zIndex > Zapatec.Window.maxNumber){
			Zapatec.Window.maxNumber = state.zIndex + 1;
		}
		//updating WCH
		if (this.WCH) {
			this.WCH.style.zIndex = state.zIndex - 1;
		}
		//updating modal
		if(this.config.modal){
			this.modal.container.style.zIndex = state.zIndex - 2;
		}
	}
	//setting content
	if(state.url || state.div || state.text){
		this.setContent("");
		if (state.url) {
			//URL content
			this.setContentUrl(state.url);
		} else if (state.div) {
			//DIV content
			this.setDivContent(state.div);
		} else if (state.text) {
			//text content
			this.setContent(state.text);
		}
	}

	return true;
};

/**
 * Depricated. Only for backward compability.
 *
 * @param left [integer] - X coordinate.
 * @param top [integer] - Y coordinate.
 */
Zapatec.Window.prototype.setPos = function(left, top) {
	this.setScreenPosition(left, top);
};

/**
 * We overwrite implemented method to make it more 
 * friendly to states. So actually this method sets
 * the coordinates of Window.
 * @param left [integer] - X coordinate.
 * @param top [integer] - Y coordinate.
 */
Zapatec.Window.prototype.setPosition = function(left, top) {
	if (!this.fireOnState("shown", function() {this.setPosition(left, top);})) {return;}
	//calling interface method in scope of this object
	Zapatec.Movable.setPosition.call(this, left, top);
	//updating state object
	this._updateState();
};

/**
 * We overwrite implemented method to make it more 
 * friendly to states. This method sets the coordinates
 * of Window on the screen.
 * @param left [integer] - X coordinate.
 * @param top [integer] - Y coordinate.
 */
Zapatec.Window.prototype.setScreenPosition = function(left, top) {
	if (!this.fireOnState("shown", function() {this.setScreenPosition(left, top);})) {return;}
	//calling interface method in scope of this object
	Zapatec.Movable.setScreenPosition.call(this, left, top);
};

/**
 * We overwrite implemented method to make it more 
 * friendly to states. This method sets the coordinates
 * of Window on the whole page (document.body).
 * @param left [integer] - X coordinate.
 * @param top [integer] - Y coordinate.
 */
Zapatec.Window.prototype.setPagePosition = function(left, top) {
	if (!this.fireOnState("shown", function() {this.setPagePosition(left, top);})) {return;}
	//calling interface method in scope of this object
	Zapatec.Movable.setPagePosition.call(this, left, top);
};

/**
 * Sets the width of the window. 
 * We overwrite interface method to make
 * it friendly for states.
 *
 * @param width [integer] - width of the window.
 */
Zapatec.Window.prototype.setWidth = function(width) {
	if (!this.fireOnState("shown", function() {this.setWidth(width);})) {return;}
	//we can only call this in case if Window is not minimized or maximized
	if (this.state.state != "simple") {return false;}
	//calling interface method in scope of this object
	Zapatec.Sizable.setWidth.call(this, width);
	//updating state object
	this._updateState();
};

/**
 * Sets the height of the window.
 * We overwrite interface method to make
 * it friendly for states.
 *
 * @param height [integer] - height of the window.
 */
Zapatec.Window.prototype.setHeight = function(height) {
	if (!this.fireOnState("shown", function() {this.setHeight(height);})) {return;}
	//we can only call this in case if Window is not minimized or maximized
	if (this.state.state != "simple") {return false;}
	//calling interface method in scope of this object
	Zapatec.Sizable.setHeight.call(this, height);
	//updating state object
	this._updateState();
};

/**
 * Sets the sizes of the window. 
 *
 * @param width [integer] - width of the window.
 * @param height [integer] - height of the window.
 */
Zapatec.Window.prototype.setSize = function(width, height) {
	this.setWidth(width);
	this.setHeight(height);
};


/**
 * Sets the sizes and position of the window. 
 *
 * @param left [integer] - X coordinate.
 * @param top [integer] - Y coordinate.
 * @param width [integer] - width of the window.
 * @param height [integer] - height of the window.
 */
Zapatec.Window.prototype.setPosAndSize = function(left, top, width, height) {
	this.setSize(width, height);
	this.setPos(left, top);
};

/*
 * Set the title of the window
 * @param type [string] the title to set to
 */ 
Zapatec.Window.prototype.setTitle = function(text) {
	if (!this.fireOnState("ready", function() {this.setTitle(text);})) {return;}
	//putting text into title element
	if (text !== '') {
		this.titleText.innerHTML = text;
	}
	//returning success
	return true;
};

/**
 * Sets the status text of the window. 
 *
 * @param mesage [string] - text to be shown.
 * @param mode [string] - currently mode forces to do some additional action when seting the text.
 *                        For example, "temp" means to store the previous value.
 */
Zapatec.Window.prototype.setStatus = function(message, mode) {
	if (!this.fireOnState("ready", function() {this.setStatus(message, mode);})) {return;}

	//to be able to use different mods of setting status text we use mode var
	if (this.config.showStatus && Zapatec.isHtmlElement(this.statusText)) {
		switch (mode) {
			//if mode "temp" current value is saved and overwritten by new one
			case "temp" : {
				this.prevStText = this.statusText.innerHTML;
				break;
			}
			
			//in case of "restore" we just restore old value saved before
			case "restore" : {
				message = this.prevStText || message;
				delete this.prevStText;
				break;
			}
			
		}
		//putting message into the status element
		this.statusText.innerHTML = message;
	}
	//returning success
	return true;
}

/* 
 * Set the content of a window.
 * @param type [string] the HTML data to set the content to.
 */

Zapatec.Window.prototype.setContent = function(text) {
	if (!this.fireOnState("shown", function() {this.setContent(text);})) return;
	//setting content
	this.content.setPaneContent(text, "html/text");
	//updating state object
	this.state.contentType = "html/text";
	this.state.content = text;
}

/* 
 * Set the content of a window from HTML element(DIV).
 * @param div [string]or [object] the HTML data to set the content to.
 */

Zapatec.Window.prototype.setDivContent = function(div) {
	if (!this.fireOnState("shown", function() {this.setDivContent(div);})) return;
	//setting content
	this.content.setPaneContent(div, "html");
	//updating state object
	this.state.contentType = "html";
	if (typeof div == "string") {
		this.state.content = div;
	} else {
		this.state.content = null;
	}
}

/* 
 * Set the content of a window from url.
 * @param div [string]or [object] the HTML data to set the content to.
 */

Zapatec.Window.prototype.setContentUrl = function(url) {
	if (!this.fireOnState("shown", function() {this.setContentUrl(url);})) return;
	//setting content
	this.content.setPaneContent(url, "html/url");
	//updating state object
	this.state.contentType = "html/url";
	this.state.content = url;
}

/**
 * Activates the window.
 */
Zapatec.Window.prototype.activate = function() {
	if (!this.fireOnState("shown", function() {this.activate();})) {return;}
	//if it is already active then do nothing
	if (this.face.className.indexOf("zpWinFront") != -1) {
		return true;
	}
	Zapatec.Window.activating = this;
	//set the current window
	if (Zapatec.Window.currentWindow) {
		Zapatec.Window.currentWindow.deactivate();
	}
	Zapatec.Window.currentWindow = this;
	Zapatec.Utils.removeClass(this.face, 'zpWinBack');
	Zapatec.Utils.addClass(this.face, 'zpWinFront');
	if (this.WCH) this.WCH.style.zIndex = Zapatec.Window.maxNumber++;
	if (this.modal) this.modal.container.style.zIndex = Zapatec.Window.maxNumber++;
	this.getContainer().style.zIndex = Zapatec.Window.maxNumber++;
	//if it is not the first one and it is not the same one as before
	
	this.fireEvent("onRaise", this);
	Zapatec.Window.activating = null;
};

/**
 * Deactivates the window.
 */
Zapatec.Window.prototype.deactivate = function() {
	if (!this.fireOnState("shown", function() {this.deactivate();})) {return;}
	//if window is already unactive - do nothing
	if (this.face.className.indexOf("zpWinBack") != -1) {
		return true;
	}
	var prevWin = Zapatec.Window.currentWindow;
	Zapatec.Utils.removeClass(this.face, 'zpWinFront');
	Zapatec.Utils.addClass(this.face, 'zpWinBack');
	Zapatec.Window.activateFreeWindow(this);
	Zapatec.Window.lastActive = this;
};

/**
 * If this window can be activated.
 * @return {boolean or string} true if can be,
 * false if can not, "min" if minimized.
 */
Zapatec.Window.prototype.canActivate = function() {
	if (!this.stateReached("ready")) {
		return false;
	}
	if (this.state.state == "min") {
		return "min";
	}
	return true;
};

/**
 * Returns the visibility of the vindow.
 */
Zapatec.Window.prototype.isVisible = function() {
	return this.widgetState == "shown" ? true : false;
};

/**
 * Shows the window.
 */ 
Zapatec.Window.prototype.show = function() {
	if (!this.fireOnState("ready", function() {this.show();})) {return;}

	this.getContainer().style.display = "block";
	if (this.content) {
		this.content.show();
	}
	if (this.config.modal == true && this.modal) {
		var zIndex = null;
		if (this.WCH) {
			zIndex = this.WCH.style.zIndex;
		} else {
			zIndex = this.getContainer().style.zIndex;
		}
		this.modal.show(zIndex - 1);
	}
	if (this.WCH) {
		this.WCH.style.visibility = "";
	}
	this.activate();
	if (this.getConfiguration().fixed) {
		this._updateState();
	}
	if (this.stateReached("ready")) {
		this.changeState("shown");
	}
	this.fireEvent("onShow", this);
	return true;
}

/**
 * Hides the window.
 */ 
Zapatec.Window.prototype.hide = function() {
	if (!this.fireOnState("ready", function() {this.hide();})) return;

	this.content.hide();
	this.getContainer().style.display = "none";
	if (this.config.modal == true && this.modal) {
		this.modal.hide();
	}
	Zapatec.Utils.hideWCH(this.WCH);
	this.deactivate();
	if (this.stateReached("ready")) {
		this.changeState("hidden");
	}
	this.fireEvent("onHide", this);
	return true;
}

/**
 * This function displays the calendar near a given "anchor" element, according
 * to some rules passed in \em opts.  The \em opts argument is a string
 * containing one or 2 letters.  The first letter decides the vertical
 * alignment, and the second letter decides the horizontal alignment relative
 * to the anchor element.  Following we will describe these options; in parens
 * we will use simple descriptions like "top to bottom" which means that the
 * top margin of the calendar is aligned with the bottom margin of the object.
 *
 * \b Vertical align:
 *
 * - T -- the calendar is completely above the element (bottom to top)
 * - t -- the calendar is above the element but might overlap it (bottom to bottom)
 * - C -- the calendar is vertically centered to the element
 * - b -- the calendar is below the element but might overlap it (top to top)
 * - B -- the calendar is completely below the element (top to bottom)
 *
 * \b Horizontal align (defaults to 'l' if no letter passed):
 *
 * - L -- the calendar is completely to the left of the element (right to left)
 * - l -- the calendar is to the left of the element but might overlap it (right to right)
 * - C -- the calendar is horizontally centered to the element
 * - r -- the calendar is to the right of the element but might overlap it (left to left)
 * - R -- the calendar is completely to the right of the element (left to right)
 *
 * @param el [HTMLElement] the anchor element
 * @param opts [string, optional] the align options, as described above.  Defaults to "Bl" if nothing passed.
 */
Zapatec.Window.prototype.showAtElement = function (el, opts) {
	if (!this.fireOnState("ready", function() {this.showAtElement(el, opts);})) {return;}

	var p = Zapatec.Utils.getElementOffset(el);
	if (!opts || typeof opts != "string") {
		this.showAt(p.x, p.y + el.offsetHeight);
		return true;
	}
	this.getContainer().style.display = "block";
	var w = this.getWidth();
	var h = this.getHeight();
	this.getContainer().style.display = "none";
	var valign = opts.substr(0, 1);
	var halign = "l";
	if (opts.length > 1) {
		halign = opts.substr(1, 1);
	}
	// vertical alignment
	switch (valign) {
	    case "T": p.y -= h; break;
	    case "B": p.y += el.offsetHeight; break;
	    case "C": p.y += (el.offsetHeight - h) / 2; break;
	    case "t": p.y += el.offsetHeight - h; break;
	    case "b": break; // already there
	}
	// horizontal alignment
	switch (halign) {
	    case "L": p.x -= w; break;
	    case "R": p.x += el.offsetWidth; break;
	    case "C": p.x += (el.offsetWidth - w) / 2; break;
	    case "l": p.x += el.offsetWidth - w; break;
	    case "r": break; // already there
	}
	p.width = w;
	p.height = h;
	//Zapatec.Utils.fixBoxPosition(p);
	this.showAt(p.x, p.y);
	return true;
}

/**
 * Shows the calendar at a given absolute position (beware that, depending on
 * the calendar element style -- position property -- this might be relative to
 * the parent's containing rectangle).
 *
 * @param x [int] the X position
 * @param y [int] the Y position
 */
Zapatec.Window.prototype.showAt = function (x, y) {
	if (!this.fireOnState("ready", function() {this.showAt(x, y);})) {return;}

	this.setPagePosition(x, y);
	this.show();
	return true;
}

/**
 * Minimizes the window.
 */ 
Zapatec.Window.prototype.minimize = function() {
	if (!this.config.showMinButton) {
		return false;
	}
	if (!this.fireOnState("ready", function() {this.minimize();})) return;

	//Do we really need to minimize
	if (this.state.state != "min" && this.titleArea) {
		var self = this;
		//this function recursively hides all the elements in the Window except title and its parents
		function hideExcept(el, exc) {
			if (el != self.container) {
				var first = el.firstChild;
				while(first) {
					if (first && first.style && first != exc) {
						if (!first.restorer) {
							first.restorer = new Zapatec.SRProp(first);
						}
						first.restorer.saveProp("style.display");
						first.style.display = "none";
					}
					first = first.nextSibling;
				}
				hideExcept(el.parentNode, el);
			}
		}
		if (this.state.state != "simple") {
			this.restore();
		}
		hideExcept(this.titleArea.parentNode, this.titleArea);
		this.content.hide();
		this.restorer.saveProps(
			"_updateState", "content", "statusText", 
			"getConfiguration().limit.minHeight"
		);
		this.content = this.statusText = this.getConfiguration().limit.minHeight = null;
		this._updateState = function() {};
		this.setHeight(Zapatec.Utils.getHeight(this.face));
		if (this.config.bottomMinimize) {
			this.setWidth(Zapatec.Window.minWinWidth);
			//Putting it to the left bottom corner in the appropriate order
			this.setScreenPosition(Zapatec.Window.minimizeLeft, "bottom");
			Zapatec.Window.minimizeLeft += Zapatec.Window.minWinWidth + 5;
		}
		//lets disable dragging
		if (!this.config.dragMin) {
			this._setCanDrag(false);
		} else {
			this._setCanDrag(true);
			this.restorer.restoreProp("_updateState");
		}
		this._setCanResize(false);
		//Need to hide some buttons and show restore one
		if (this.state.state == "max") {
			this.showButton("maxButton");
		} else {
			this.showButton("restoreButton");
		}
		this.hideButton("minButton");
		//storing old state for restore
		this.state.prevState = this.state.state;
		//setting new state
		this.state.state = "min";
		//if the window is not fixed need to fixate it on the screen
		if (!this.getConfiguration().fixed) {
			Zapatec.FixateOnScreen.register(this.getContainer());
			Zapatec.FixateOnScreen.register(this.WCH);
		}
		//deactivateing window
		this.deactivate();
	} else {
		return false;
	}
	//calling handler
	this.fireEvent("onMinimize", this);

	return true;
}

/**
 * Maximizes the window.
 */ 
Zapatec.Window.prototype.maximize = function() {
	if (!this.config.showMaxButton) {
		return false;
	}
	var self = this;
	if (!this.fireOnState("ready", function() {self.maximize();})) return;

	if (this.state.state != "max") {
		var sizes = Zapatec.Utils.getWindowSize();
		//Need to hide some buttons and show restore one, restore some properties of the window, etc.
		if (this.state.state == "min") {
			this.restore();
		}
		this.showButton("restoreButton");
		this.hideButton("maxButton");
		//lets disable dragging
		this._setCanDrag(false);
		this._setCanResize(false);
		this.restorer.saveProp("_updateState");
		this._updateState = function() {};
		this.setHeight(this.getHeight());
		this.setScreenPosition(0, 0);
		this.setSize(sizes.width, sizes.height);
		//setting previous state to be restored correctly
		this.state.prevState = "simple";
		//setting new state
		this.state.state = "max";
		//if the window is not fixed need to fixate it on the screen
		if (!this.getConfiguration().fixed) {
			Zapatec.FixateOnScreen.register(this.getContainer());
			Zapatec.FixateOnScreen.register(this.WCH);
		}
		this.activate();
	} else {
		return false;
	}
	this.fireEvent("onMaximize", this);
	
	return true;
}

/**
 * Restores the window.
 */ 
Zapatec.Window.prototype.restore = function() {
	if (!this.config.showMaxButton && !this.config.showMinButton) {
		return false;
	}
	var self = this;
	if (!this.fireOnState("ready", function() {self.restore();})) return;
	
	if (this.state.prevState == "max") {
		return this.maximize();
	}
	if (this.state.state != "simple") {
		var self = this;
		//this function recursively hides all the elements in the Window except title and its parents
		function showAll(el) {
			if (el != self.container) {
				var first = el.firstChild;
				while(first) {
					if (first && first.restorer) {
						first.restorer.restoreProp("style.display");
						first.restorer = null;
					}
					first = first.nextSibling;
				}
				showAll(el.parentNode);
			}
		}
		//Need to hide some buttons and show restore one
		if (this.config.showMaxButton) {
			this.showButton("maxButton"); 
		}
		if (this.config.showMinButton) {
			this.showButton("minButton");
		}
		this.hideButton("restoreButton");
		//setting new state
		var wasState = this.state.state;
		this.state.state = "simple";
		//if the window is not fixed need to unregister 
		//it from being fixated on the screen
		if (wasState == "min" && this.config.bottomMinimize) {
			Zapatec.Window.sortMin(this);
		}
		if (!this.getConfiguration().fixed) {
			Zapatec.FixateOnScreen.unregister(this.getContainer());
			Zapatec.FixateOnScreen.unregister(this.WCH);
			this.setPosition(this.state.left, this.state.top);
		} else {
			this.setScreenPosition(this.state.left, this.state.top);
		}
		//seting the initial pos and sizes
		this.setSize(this.state.width, this.state.height);
		//enable dragging
		this._setCanDrag(true);
		//enable resizing
		this._setCanResize(true);
		if (wasState == "min") {
			showAll(this.titleArea);
		}
		this.restorer.restoreProps(
			"_updateState", "content", "statusText",
			"getConfiguration().limit.minHeight"
		);
		if (wasState == "min") {
			this.content.show();
		}
		//activateing this window
		this.activate();
	}

	this.fireEvent("onRestore", this);

	return true;
}

/**
 * Closes the window. Currently does not destroys the window object, just the HTML part of it
 */ 
Zapatec.Window.prototype.close = function() {
	var self = this;
	if (!this.fireOnState("ready", function() {self.close();})) return;
	
	this.restore();
	this.deactivate();
	// Return content back to the place it was taken from
	// Destroy window
	this.fireEvent("onClose", this);
	if (!this.config.hideOnClose) {
		if (this.content.destroy) this.content.destroy();
		this.content = null;
		
		this.restoreOfDrag();
		this.restoreOfResize();
		if (this.minButton.destroy) this.minButton = this.minButton.destroy();
		if (this.maxButton.destroy) this.maxButton = this.maxButton.destroy();
		if (this.closeButton.destroy) this.closeButton = this.closeButton.destroy();
		if (this.restoreButton.destroy) this.restoreButton = this.restoreButton.destroy();

		for(var iEl in this) {
			if (this[iEl] && typeof this[iEl] == "object" && this[iEl].nodeType && iEl != "container" && iEl != "WCH") {
				this[iEl] = null;
			}
		}
		if (this.config.modal == true && this.modal) {
			this.modal.hide(true);
			delete this.modal;
		}
		this.config = null;
		this.restorer = this.restorer.destroy();
		if (this.container.outerHTML) {
			this.container.outerHTML = "";
		} else {
			Zapatec.Utils.destroy(this.container);
		}
		if (this.WCH && this.WCH.outerHTML) {
			this.WCH.outerHTML = "";
		} else if (this.WCH) {
			Zapatec.Utils.destroy(this.WCH);
		}
		delete this.container;
		delete this.WCH;
		this.changeState("destroyed");
		this.removeEvent("onRestore");
		this.removeEvent("onMinimize");
		this.removeEvent("onMaximize");
		this.removeEvent("onShow");
		this.removeEvent("onHide");
		this.removeEvent("onRaise");
		this.removeEvent("onContentLoad");
		this.removeEvent("privileged_execution_on");
		this.removeEvent("privileged_execution_off");
		this.removeEvent("delayed_execution_on");
		this.removeEvent("delayed_execution_off");
	} else {
		this.hide();
	}
	return true;
}
// $Id: window-globals.js 6650 2007-03-19 10:14:14Z slip $
/**
 *
 * Copyright (c) 2004-2006 by Zapatec, Inc.
 * http://www.zapatec.com
 * 1700 MLK Way, Berkeley, California,
 * 94709, U.S.A.
 * All rights reserved.
 */

// Global that keeps track of z-index of windows
Zapatec.Window.maxNumber = 5;
// Global that holds the pointer to the current window
Zapatec.Window.currentWindow = null;
// Global that holds the current position to minimize to
Zapatec.Window.minimizeLeft = 0;
// Global that determines the minimal width of the window
Zapatec.Window.minWinWidth = 120;
// Global that keeps last active window
Zapatec.Window.lastActive = null;

/**
 * \internal 
 * Sorts all the minimized windows at the bottom when one of them was restored to the simple state.
 */
Zapatec.Window.sortMin = function (raised) {
	//getting the place where raised Window was
	var place = raised.getScreenPosition().x, win = null, left = 0;
	//iterating through asll widgets
	for (var i = 0; i < Zapatec.Widget.all.length; ++i) {
		//we work only with Window widget
		if (Zapatec.Widget.all[i].widgetType == "window") {
			//taking window
			win = Zapatec.Widget.all[i];
			//if it is there and minimized lets move it
			if (win && win.state.state == "min") {
				//taking its position
				left = win.getScreenPosition().x;
				//if it is after the raised one lets move it for Zapatec.Window.minWinWidth
				if (left > place) {
					left -= Zapatec.Window.minWinWidth + 5;
					win.setScreenPosition(left - (Zapatec.Utils.bodyOffset ? Zapatec.Utils.bodyOffset.left : 0), null);
				}
			}
		}
	}
	//clearing the reference
	win = null;
	//decrementing Zapatec.Window.minimizeLeft
	Zapatec.Window.minimizeLeft -= Zapatec.Window.minWinWidth + 5;
};

/**
 * Activates the window which is free.
 * @param me {object} window that requested this(can not be activated).
 * @return {boolean} true if success, otherwise false.
 */
Zapatec.Window.activateFreeWindow = function(me) {
	if (Zapatec.Window.activating) {
		return false;
	}
	//trying to activate last active window
	var win = Zapatec.Window.lastActive;
	Zapatec.Window.lastActive = me;
	if (win && win != me && win.canActivate() === true) {
		win.activate();
		return true;
	}
	//otherwise we seek possible one in array of all widgets
	var allW = Zapatec.Widget.all;
	var minimized = null;
	for(var iWidget = 0; iWidget < allW.length; ++iWidget) {
		win = allW[iWidget];
		//if it is window and can be activated - then lets do it!
		if (win && win.widgetType == "window" && win != me) {
			if (win.canActivate() === true) {
				win.activate();
				return true;
			} else if (win.canActivate() == "min" && !minimized) {
				minimized = win;
			}
		}
	}
	if (minimized) {
		minimized.activate();
		return true;
	} else {
		Zapatec.Window.currentWindow = null;
		return false;
	}
}; 

//who is activating currently :)
Zapatec.Window.activating = null;

/**
 * A function that is called to handle mousedown event for our window.
 * @param ev [object] - event object.
 * @param win [object] - our window object.
 * @param target [object] - "pushed" element.
 */
Zapatec.Window.mouseDown = function (ev, win, target) {
	//trying to activate the Window
	if (!win.config.raiseOnlyOnTitle) {
		win.activate();
	} else if (target && target.buttonType == "title") {
		win.activate();
	}
	//if it content we should not stop events as it disables selection
	if (target && target.buttonType != "content") {
		return Zapatec.Utils.stopEvent(ev);
	}
};

/**
 * A function that is called to handle mousemove event for our window.
 * @param ev [object] - event object.
 * @param win [object] - our window object.
 * @param target [object] - "pushed" element.
 */
Zapatec.Window.mouseMove = function (ev, win, target) {
};

/**
 * A function that is called to handle mouseup event for our window.
 * @param ev [object] - event object.
 * @param win [object] - our window object.
 * @param target [object] - "pushed" element.
 */
Zapatec.Window.mouseUp = function (ev, win, target) {
};

/**
 * A function that is called to handle doubleclick event for our window.
 * @param ev [object] - event object.
 * @param win [object] - our window object.
 * @param target [object] - "pushed" element.
 */
Zapatec.Window.dblClick = function (ev, win, target) {
	//proceeding double click
	if (target) {
		switch (target.buttonType) {
			case "title" : {
				switch (win.state.state) {
					case "min" : {
						//restore from minimized on double click
						win.restore();
						
						break;
					}
					case "max" : {
						//restore from maximize on double click
						win.restore();
						
						break;
					}
					case "simple" : {
						//maximize on double click if it is simple
						win.maximize();
						
						break;
					}
				}
				
				break;
			}
		}
		//we need to do drag end cause in reality dragging was started
		win.dragEnd(ev);
		//if it content we should not stop events as it disables selection
		if (target.buttonType != "content") {
			return Zapatec.Utils.stopEvent(ev);
		}
	}
}

// $Id: window-utils.js 6770 2007-03-27 10:49:54Z slip $
/**
 *
 * Copyright (c) 2004-2006 by Zapatec, Inc.
 * http://www.zapatec.com
 * 1700 MLK Way, Berkeley, California,
 * 94709, U.S.A.
 * All rights reserved.
 */

/**
 * Parses given DOM element to save references into objects properties.
 * All the elements to be saved as a reference had to have a word starting
 * with 'area' in there class name. So for example an element with class name
 * areaTitle will be parsed into this.title property and those className will 
 * be removed.
 * @param el [HTML element] - element to parse;
 * @return - true if success, otherwise false;
 */
Zapatec.Window.prototype.parseDom = function(el) {
	var classes = "";
	//the el needs to be a DOM HTML element
	if (!el || typeof el != "object" || !el.nodeType) {
		return false;
	}
	//seeks the elements with the className starting with word 'area',
	//extracts the rest part of this class name, creates the reference 
	//(a property of the object) with such name, removes this class.
	//I didn't knew which way to mark the elements which needed to have reference
	//in our object, and decided (by advise) to use className starting with 'area'.
	//Example: 'areaContent', 'areaTitle', etc. will create this.content, this.title, etc.
	if (el.className) {
		classes = el.className.match(/area(\w+)/);
		//this way we mark all the elements which belong to the widget with a reference to it.
		el.win = true;
		if (classes) {
			el.id = "zpWin" + this.id + classes[1];
			classes[1] = classes[1].charAt(0).toLowerCase() + classes[1].substring(1);
			this.createProperty(this, classes[1], el);
			Zapatec.Utils.removeClass(el, classes[0]);
		}
	}
	//to go through all the childs we use recursive calls of this function for every child.
	var child = el.firstChild;
	while(child) {
		this.parseDom(child);
		child = child.nextSibling;
	}
	
	return true;
};

/**
 * Shows the specified button of the window.
 * @param button {string} string pointing to button name.
 */
Zapatec.Window.prototype.showButton = function(button) {
	this.restorer.restoreProp(button + ".getContainer().parentNode.style.display");
};

/**
 * Hides the specified button of the window.
 * @param button {string} string pointing to button name.
 */
Zapatec.Window.prototype.hideButton = function(button) {
	this.restorer.saveProp(button + ".getContainer().parentNode.style.display");
	this[button].getContainer().parentNode.style.display = "none";
};

/**
 * Reconfigurating the object due to the config options.
 */
Zapatec.Window.prototype.reconfig = function() {
	if (!this.fireOnState("ready", function() {this.reconfig();})) {return;}
	var config = this.getConfiguration();
	//Hiding title if needed
	if (!config.showTitle) {
		this.restorer.saveProp("titleArea.style.display");
		this.titleArea.style.display = "none";
	} else {
		this.restorer.restoreProp("titleArea.style.display");
		//hiding buttons if needed
		if (!config.showMinButton || this.state.state == "min") {
			this.hideButton("minButton");
		} else {
			this.showButton("minButton");
		}
		if (!config.showMaxButton || this.state.state == "max") {
			this.hideButton("maxButton");
		} else {
			this.showButton("maxButton");
		}
		if (this.state.state != "max" && this.state.state != "min") {
			this.hideButton("restoreButton");
		} else {
			this.showButton("restoreButton");
		}
		if (!config.showCloseButton) {
			this.hideButton("closeButton");
		} else {
			this.showButton("closeButton");
		}
	}
	//Hiding status if needed
	if (!config.showStatus) {
		this.restorer.saveProp("statusText.style.display");
		this.statusText.style.display = "none";
	} else {
		this.restorer.restoreProp("statusText.style.display");
	}
	//making the modal cover
	if (config.modal && !this.modal) {
		this.modal = new Zapatec.Modal({
			themePath : Zapatec.zapatecPath + "../zpextra/themes/indicator/"
		});
		this.modal.create();
	}
};


/**
 * This function assigns event handlers and implements "pushed" element finding.
 *
 * "Pushed" element finding is implemented the following way: all the event handlers see one
 * global variable target. When mouse is down on some element we try to get its buttonType property
 * or seek this property in elements parents. If the element with the buttonType is found it is put
 * into target variable. 
 */
Zapatec.Window.prototype.addEvents = function () {
	var self = this, target = null;
	Zapatec.Utils.addEvent(this.container, "mousedown", function (ev) {
		ev = ev || window.event; 
		target = Zapatec.Utils.getTargetElement(ev);
		while(!target.buttonType && (target != self.container)) {
			target = target.parentNode;
		}
		if (!target.buttonType) {target = null;}
		var result = Zapatec.Window.mouseDown(ev, self, target);
		target = null;
		return result;
	});
	if (Zapatec.is_gecko) {
		Zapatec.Utils.addEvent(this.container, "click", function (ev) {
			var result = null;
			ev = ev || window.event; 
			if (ev.detail > 1) {
				target = Zapatec.Utils.getTargetElement(ev);
				while(!target.buttonType && (target != self.container)) {
					target = target.parentNode;
				}
				if (!target.buttonType) {target = null;}
				result = Zapatec.Window.dblClick(ev, self, target);
			}
			target = null;
			return result;
		});
	} else {
		Zapatec.Utils.addEvent(this.container, "dblclick", function (ev) {
			ev = ev || window.event; 
			target = Zapatec.Utils.getTargetElement(ev);
			while(!target.buttonType && (target != self.container)) {
				target = target.parentNode;
			}
			if (!target.buttonType) {target = null;}
			var result = Zapatec.Window.dblClick(ev, self, target);
			target = null;
			return result;
		});
	}
};

/**
 * Overwriting interface method.
 */
Zapatec.Window.prototype._getDraggableHooks = function() {
	return this.titleText;
};

/**
 * Overwriting interface method.
 */
Zapatec.Window.prototype.canDrag = function() {
	return this.getConfiguration().canDrag;
};

/**
 * Overwriting interface method.
 * @param on {boolean} turning on or off.
 */
Zapatec.Window.prototype._setCanDrag = function(on) {
	if (!on) {
		if (typeof this.restorer.getProp("getConfiguration().canDrag") == "undefined") {
			this.restorer.saveProp("getConfiguration().canDrag");
		}
		this.getConfiguration().canDrag = on;
	} else {
		if (typeof this.restorer.getProp("getConfiguration().canDrag") != "undefined") {
			this.restorer.restoreProp("getConfiguration().canDrag");
		}
	}
};

/**
 * Overwriting interface method.
 */
Zapatec.Window.prototype.getDragConfig = function() {
	var config = this.getConfiguration();
	return {
		method : config.dragMethod,
		dragCSS : config.addDragCSS,
		overwriteCSS : config.newDragCSS,
		copyChilds : false,
		stopEvent : false,
		eventCapture : true
	};
};

/**
 * Overwriting interface method.
 * @param config {object} new set of configuration.
 */
Zapatec.Window.prototype.setDragConfig = function(config) {};

/**
 * Overwriting interface method.
 * @param dim {string} dimension of sizing.
 */
Zapatec.Window.prototype.getSizableElements = function(dim) {
	if (dim == "width") {
		return [
			this.titleText, 
			this.content ? this.content.getContainer() : null, 
			this.getConfiguration().showStatus ? this.statusText : null, 
			this.getContainer(), 
			this.WCH
		];
	} else if (dim == "height") {
		return [
			this.content ? this.content.getContainer() : null, 
			this.getContainer(), 
			this.WCH
		];
	} else {
		return [
			this.titleText, 
			this.content ? this.content.getContainer() : null, 
			this.getConfiguration().showStatus ? this.statusText : null, 
			this.getContainer(), 
			this.WCH
		];
	}
};

/**
 * Overwriting interface method.
 */
Zapatec.Window.prototype._getAutoSizableElement = function() {
	return this.content.getContainer();
};

/**
 * Overwriting interface method.
 */
Zapatec.Window.prototype.getSizingConfig = function() {
	return {
		limit : this.getConfiguration().limit,
		direction : "both"
	};
};

/**
 * Overwriting interface method.
 * @param config {object} new set of configuration.
 */
Zapatec.Window.prototype.setSizingConfig = function(config) {
	if (typeof config.limit == "object") {
		this.getConfiguration().limit.minWidth = config.limit.minWidth;
		this.getConfiguration().limit.maxWidth = config.limit.maxWidth;
		this.getConfiguration().limit.minHeight = config.limit.minHeight;
		this.getConfiguration().limit.maxHeight = config.limit.maxHeight;
	}
};

/**
 * Overwriting interface method.
 */
Zapatec.Window.prototype.getMovableElements = function() {
	return [this.getContainer(), this.WCH];
};

/**
 * Overwriting interface method.
 */
Zapatec.Window.prototype.getMoveConfig = function() {
	return {
		limit : this.getConfiguration().limit,
		moveLayer : document.body,
		direction : "both",
		preserveSizes : true,
		followShape : false
	};
};

/**
 * Overwriting interface method.
 * @param config {object} new set of configuration.
 */
Zapatec.Window.prototype.setMoveConfig = function(config) {
	if (typeof config.limit == "object") {
		this.getConfiguration().limit.minX = config.limit.minX;
		this.getConfiguration().limit.maxX = config.limit.maxX;
		this.getConfiguration().limit.minY = config.limit.minY;
		this.getConfiguration().limit.maxY = config.limit.maxY;
	}
};

/**
 * Overwriting interface method.
 */
Zapatec.Window.prototype._getResizableHooks = function() {
	return null;
};

/**
 * Overwriting interface method.
 */
Zapatec.Window.prototype.canResize = function() {
	return this.getConfiguration().canResize;
};

/**
 * Overwriting interface method.
 * @param on {boolean} turning on or off.
 */
Zapatec.Window.prototype._setCanResize = function(on) {
	if (!on) {
		if (typeof this.restorer.getProp("getConfiguration().canResize") == "undefined") {
			this.restorer.saveProp("getConfiguration().canResize");
		}
		this.getConfiguration().canResize = on;
	} else {
		if (typeof this.restorer.getProp("getConfiguration().canResize") != "undefined") {
			this.restorer.restoreProp("getConfiguration().canResize");
		}
	}
};

/**
 * Overwriting interface method.
 */
Zapatec.Window.prototype.getResizeConfig = function() {
	return {
		stopEvent : false,
		eventCapture : true,
		direction : this.getConfiguration().resizeDirection,
		borderThickness : 10,
		cornerThickness : 10
	};
};

/**
 * Overwriting interface method.
 * @param config {object} new set of configuration.
 */
Zapatec.Window.prototype.setResizeConfig = function(config) {
	if (typeof config.direction == "string" && config.direction.length > 2) {
		this.getConfiguration().resizeDirection = config.direction;
	}
};
// $Id: window-states-modes.js 6650 2007-03-19 10:14:14Z slip $
/**
 *
 * Copyright (c) 2004-2006 by Zapatec, Inc.
 * http://www.zapatec.com
 * 1700 MLK Way, Berkeley, California,
 * 94709, U.S.A.
 * All rights reserved.
 */

/**
 * Sets the widgets privillage mode to on.
 * @param mode [string] - mode to set.
 */
Zapatec.Window.prototype.setModeOn = function(mode) {
	//nothing to turn on
	if (typeof mode != "string") {
		return false;
	}
	//no mode object - let's create it
	if (!this.widgetModes[mode]) {
		this.widgetModes[mode] = {};
	}
	//setting it to be on
	this.widgetModes[mode].on = true;
	//saving the caller method, which turned the mode on
	this.widgetModes[mode].caller = this.setModeOn.caller;
	//firing event of turning specified mode on
	this.fireEvent(mode + "_on", this);
	//returning success
	return true;
};

/**
 * Sets the widgets privillage mode to off.
 * @param mode [string] - mode to set.
 */
Zapatec.Window.prototype.setModeOff = function(mode) {
	//no mode specified or non existing mode - returning false
	if (typeof mode != "string" || !this.widgetModes[mode]) {
		return false;
	}
	//setting mode to be off
	this.widgetModes[mode].on = false;
	//clearing caller
	this.widgetModes[mode].caller = null;
	//firing event of turning specified mode off
	this.fireEvent(mode + "_off", this);
	//returning success
	return true;
};

/** 
 * Returns true if the mode is on, otherwise false
 * @param mode [string] - mode to check
 * @return true if the mode is on, otherwise false
 */
Zapatec.Window.prototype.modeOn = function(mode) {
	//checking if mode is on
	if (this.widgetModes[mode] && this.widgetModes[mode].on === true) {
		return true;
	}
	//mode is off
	return false;
};

/**
 * Returns true if called function was called from the method that set the mode.
 * @param mode [string] - mode to check
 * @param caller [function] - called function.
 * @return returns true if called function was called from the method that set the mode.
 */
Zapatec.Window.prototype.modeSameCaller = function(mode, caller) {
	//walking up in caller chain to determine if there is a function we seek
	while(caller) {
		//same caller
		if (caller.caller == this.widgetModes[mode].caller) {
			//returning success
			return true;
		}
		//going up if not
		caller = caller.caller;
	}
	//returning failure
	return false;
};

/**
 * Checks if needed state was reached and tryes to fire function exactly when it needs.
 * @param state [string] - required state;
 * @param func [function] - function needed to be fired
 * @param first [boolean] - should it go first
 * @return true if the state was already reached
 */
Zapatec.Window.prototype.fireOnState = function(state, func) {
	var self = this;
	//if immediate execution mode is on we don't need to schedule
	if (this.modeOn("immediate_execution") && this.modeSameCaller("immediate_execution", this.fireOnState)) {
		return true;
	}
	//special way for BODY load
	if (state == "body_loaded") {
		//Object was destroyed!
		if (!this.stateReached("created")) {
			return false;
		}
		//not loaded? - let's try again in 50 msecs
		if (!Zapatec.windowLoaded) {
			setTimeout(function() {func.call(self);}, 50);
			return false;
		}
		
		return true;
	}
	//was state reached?
	if (!this.stateReached(state)) {
		//Object was destroyed!
		if (!this.stateReached("created")) {
			return false;
		}
		//if priveleged execution mode turned on put listener to
		//high priority events array
		if (this.modeOn("privileged_execution") && this.modeSameCaller("privileged_execution", this.fireOnState)) {
			this.highPriorityEvents.push({"state" : state, "listener" : func, "executed" : false});
			return false;
		}	
		//if delayed execution mode turned on put listener to
		//delayed events array
		if (this.modeOn("delayed_execution")) {
			this.delayedEvents.push({"state" : state, "listener" : func});
			return false;
		}
		//or lets just add listener to the state
		this.addEventListener(state, func);
		//returning false, as function can not be executed
		//and was scheduled
		return false;
	} else {
		//state was reached we can execute function
		return true;
	}
};

/**
 * Changes the state of the widget, firing all the events planned
 * @param state [string] - state to set.
 * @return true if succeeds, otherwise false
 */
Zapatec.Window.prototype.changeState = function(state) {
	//if delayed execution was on lets schedule changing state
	//on turning this mode off
	if (this.modeOn("delayed_execution")) {
		this.addEventListener("delayed_execution_off", function() {this.changeState(state);});
	}
	//if priveleged execution was on lets turn it off
	if (this.modeOn("privileged_execution")) {
		this.setModeOff("privileged_execution");
	}
	//changing state
	this.widgetState = state;
	//no execution scheduled - no action
	if (!this.isEvent(state)) {
		return;
	}
	//executing listeners
	var listeners = this.getEventListeners(state);
	for(var ii = 0; ii < listeners.length; ++ii) {
		//if delayed execution wasn't on lets execute the function,
		//otherwise lets schedule changing state on turning this mode off
		if (!this.modeOn("delayed_execution")) {
			listeners[ii].apply(this);
		} else {
			this.addEventListener("delayed_execution_off", listeners[ii]);
		}
	}
	//clearing events
	this.removeEvent(state);
	//returning success
	return true;
};

/**
 * This method tells you wether the state you need was reached or maybe already passed.
 * Right now we have following states:
 * 'destroyed' - the object was destroyed;
 * 'created' - the instance of the object was created;
 * 'inited' - the object was inited (this include initing all variables, calling parent
 *            init and starting loading structure);
 * 'loaded' - the structure is loaded and parsed;
 * 'ready' - object has all the parts ready for work;
 * 'hidden' - object is visually hidden;
 * 'shown' - object is visible;
 * @param state [string] - the name of the state you need to check;
 * @return - true if the state was reached or already passed, otherwise false
 */
Zapatec.Window.prototype.stateReached = function(state) {
	//getting current state priority.
	//if there is no such in our priority array we give it the highest priority, 
	//which means count of states avaliable in the array.
	var currentState = this.priorities[this.widgetState] || (this.priorities[this.widgetState] !== 0 ? this.priorities.count : 0);
	//getting passed state priority.
	//if there is no such in our priority array we give it the highest priority, 
	//which means count of states avaliable in the array.
	state = this.priorities[state] || (this.priorities[state] !== 0 ? this.priorities.count : 0);
	//and now compareing them
	if (state > currentState) {return false;}
	return true;
};
// $Id: window-setup.js 6650 2007-03-19 10:14:14Z slip $
/**
 *
 * Copyright (c) 2004-2006 by Zapatec, Inc.
 * http://www.zapatec.com
 * 1700 MLK Way, Berkeley, California,
 * 94709, U.S.A.
 * All rights reserved.
 */

/**
 * This is a setup function for Window object.
 *
 * It gathers some mostly common routines when seting up the Window object on your page.
 * For example it creates the simple window and shows it, or creates the popup window.
 * Mostly in all cases (except popup window) it will be initialy shown. Possible enhancement
 * is to add a property to control the initial state of the window (including minimized, maximized, etc)
 *
 * @param config [object] - all parameters are passed as the properties of this object. Many of them are 
 * the same as for the constructor.
 * 
 * Function recognizes the following properties of the config object (duplicated properties are listed in 
 * the constructor description so are not included here):
 * \code
 *    prop. name   | description
 *  -------------------------------------------------------------------------------------------------
 *   popup         | if it is set than window will be a popup window, triggered by the element you passed in this variable.
 *   triggerEvent  | if popup is set than this defines which event of the trigger element will force the window to popup. 
 *                 | Possible values: click, mousemove, mouseover, or any DOM event name.
 *   align         | align of the popup window relational to the trigger object. For information on values see the Zapatec.Window.prototype.showAtElement function description
 *   width         | initial width of the window in pixels.
 *   height        | initial height of the window in pixels.
 *   left          | initial X coordinate of the window.
 *   top           | initial Y coordinate of the window.
 *   title         | title of the window.
 *   content       | content of the window.
 *   divContent    | id of or "pointer" to the HTML element containing the content for the window.
 *   urlContent    | URL to load the content from.
 *   initialState  | initial state of the window: "hidden", "visible"
 *   
 * \endcode
 */
Zapatec.Window.setup = function (config) {
	var winConfig = Zapatec.Hash.remove(config, 
		"popup", "triggerEvent", "align", "width",
		"height", "left", "top", "title", "content",
		"divContent", "urlContent", "initialState"
	) || {}, 
	win = null;
	if (config.popup) {
		winConfig.hideOnClose = true;
		win = new Zapatec.Window(winConfig);
		win.create(0, 0, config.width || win.config.minWidth, config.height || win.config.minHeight);
		if (typeof config.popup == "string") {
			config.popup = document.getElementById(config.popup);
		}
		if (!config.popup) {
			alert("You specified wrong trigger element!");
			win.close();
			return;
		}
		if (!config.triggerEvent) {
			config.triggerEvent = "click";
		}
		if (!config.align) {
			config.align = null;
		}
		el = config.popup;
		el["on" + config.triggerEvent] = function (ev) {
			win.show();
			win.restore();
			win.setWidth(config.width || win.config.minWidth);
			win.setHeight(config.height || win.config.minHeight);
			win.hide();
			if (!win.config.visible) {
				win.showAtElement(this, config.align);
			}
			if (config.title) {
				win.setTitle(config.title);
			}
			if (config.content) {
				win.setContent(config.content);
			}
			if (config.divContent) {
				win.setDivContent(config.divContent);
			}
			if (config.urlContent) {
				win.setContentUrl(config.urlContent);
			}
			
			return false;
		};
		
	} else {
		win = new Zapatec.Window(winConfig);
		win.create(config.left || 0, config.top || 0, config.width || win.config.minWidth, config.height || win.config.minHeight);
		if (config.initialState != "hidden") {
			win.show();
		}
		if (config.title) {
			win.setTitle(config.title);
		}
		if (config.content) {
			win.setContent(config.content);
		}
		if (config.divContent) {
			win.setDivContent(config.divContent);
		}
		if (config.urlContent) {
			win.setContentUrl(config.urlContent);
		}
	}
	
	return win;
};
